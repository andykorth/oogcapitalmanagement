<style>
    textarea {
        resize: none;
        width: 100%;
    }

    label {  
        display: block;
        margin-top: 1px;
    }

    #price-compare .inputs {
        display: flex;
        flex-direction: column;
        gap: 0.8rem;
        max-width: 340px;
    }

    #price-compare select {
        padding: 4px 6px;
    }

    #priceTable {
        width: auto; /* override the 100% */
        min-width: 50%;
        margin-left: auto;
        margin-right: auto;
        margin-top: 1em;
        border-collapse: collapse;
    }

    #priceTable td, #priceTable th {
        border-bottom: 1px solid #ddd;
        padding: 4px 6px;
    }

    .expand-row {
        background: #f7f7f7;
    }

    .green-highlight {
        background-color: #d1fae5 !important; 
    }
    .dark .green-highlight {
        background-color: #002c15 !important; 
    }

  .expand-details-table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 0.5rem;
  }

  table {
    table-layout: fixed;
    max-width: 100%;     /* prevents expanding past container */
  }

  .expand-details-table th,
  .expand-details-table td {
    border: 1px solid #ddd;
    padding: 4px 6px;
    vertical-align: middle;
  }

  .expand-details-table a {
    color: inherit;
    text-decoration: none;
  }

  [data-tooltip]:hover::after {
    display: block;
    position: absolute;
    content: attr(data-tooltip);
    border: 1px solid black;
    background: var(--bg-primary);
    padding: .25em;
  }

  .sell-text {
    color: #b91c1c;
    font-weight: bold;
  }
  .dark .sell-text {
    color: #fca5a5; 
  }

  .buy-text {
    color: #065f46;
    font-weight: bold;
  }
  .dark .buy-text {
    color: #6ee7b7; 
  }

  .self-text {
    text-decoration: underline;
    font-weight: bold;
  }
  .dark .self-text {
    text-decoration: underline;
    font-weight: bold;
  }



  .sell-text,
  .buy-text {
    white-space: nowrap;        /* never wrap */
    overflow: hidden;           /* hide anything too long */
    text-overflow: ellipsis;    /* optional: "..." at end */
    display: block;             /* or inline-block; needed for overflow rules */
    max-width: 100%;            /* ensures it respects parent container width */
  }

  .info-icon {
    cursor: help;
    font-size: 14px;
    padding: 2px;
  }

  .col-check {
    width: 32px;        /* small, tight */
    text-align: center;
  }

  .col-info {
    width: 32px;
    text-align: center;
  }

  .col-expand {
    width: 60px;        /* enough for the button */
    text-align: center;
  }

  /* Make sure cells don't stretch */
  .col-check input,
  .col-info span,
  .col-expand button {
    display: inline-block;
  }

</style>

<div id="price-compare" class="calculator">
  <h3>Price Comparison Tool</h3>

  <div class="inputs">
    <label>
      Filter by Exchange:
      <select id="exchangeFilter">
        <option value="ALL">All</option>
        <option value="AI1">AI1</option>
        <option value="CI1">CI1</option>
        <option value="CI2">CI2</option>
        <option value="IC1">IC1</option>
        <option value="NC1">NC1</option>
        <option value="NC2">NC2</option>
      </select>
    </label>

    <label>
      Filter by Material:
      <input type="text" id="materialFilter" placeholder="e.g. H2O">
    </label>

    <label>
      <input type="checkbox" id="hideNoPrices">
      Hide materials with no prices
    </label>

    <label>
      Show:
      <select id="bidAskSelect">
        <option value="bids">Show bids</option>
        <option value="asks">Show asks</option>
      </select>
    </label>

    <label>
      Percent Markup over Modeled (%):
      <input type="number" id="markupInput" value="2" step="0.1">
    </label>

    <div id="actionModeFields">

      <label>
        Available Funds for trade:
        <input type="number" id="fundsInput" value="10000000" min="0">
      </label>
      
      <label>
        Min Percent Spread (%):
        <input type="number" id="minSpreadInput" value="4" step="0.1">
      </label>

      <label>
        Min Volume to Trade On: (in $)
        <input type="number" id="minVol" value="" min="0">
      </label>
      <label>
        Max Volume to Trade On: (in $)
        <input type="number" id="maxVol" value="" min="0">
      </label>
      <label>
        Your company code
        <input type="text" id="companyCode" value="ARCL">
      </label>

      
    </div>

    <button id="loadPrices">
      Load Comparison Data
    </button>

    <p id="calculatorStatus" style="font-weight: bold; margin-top: 0.5rem;"></p>
  </div>

  <table id="priceTable" style="display: none;">
    <thead id="priceHead"></thead>
    <tbody id="priceBody"></tbody>
  </table>

  <button id="makeBidsBtn">
    Calculate Bids
  </button>
  <button id="copyJsonBids">Copy JSON Bids</button>

  <p id="bidResult" style="white-space: pre-wrap; margin-top: 1em;"></p>
</div>

<script type="module">
  import { fetchFullCXData, fullCXData } from "/pricing-and-materials.js";
  import { loadModeledPrices, modeledPrices } from "/pricing-and-materials.js";

  const btn = document.getElementById("loadPrices");
  const status = document.getElementById("calculatorStatus");
  const table = document.getElementById("priceTable");
  const thead = document.getElementById("priceHead");
  const tbody = document.getElementById("priceBody");

  const exchangeFilter = document.getElementById("exchangeFilter");
  const markupInput = document.getElementById("markupInput");
  const materialFilter = document.getElementById("materialFilter");
  const hideNoPrices = document.getElementById("hideNoPrices");
  const bidAskSelect = document.getElementById("bidAskSelect");
  const fundsInput = document.getElementById("fundsInput");
  const minSpreadInput = document.getElementById("minSpreadInput");
  const actionModeFields = document.getElementById("actionModeFields");
  
  document.getElementById("makeBidsBtn").addEventListener("click", makeBids);

  exchangeFilter.addEventListener("change", () => {
    if (exchangeFilter.value === "ALL") {
      actionModeFields.style.display = "none";
    } else {
      actionModeFields.style.display = "";
    }
  });

  materialFilter.addEventListener("input", () => {
    const q = materialFilter.value.trim().toUpperCase();

    for (const row of tbody.querySelectorAll("tr[id^='row-']")) {
      const mat = row.id.replace("row-", "");
      const match = mat.includes(q);
      row.style.display = match ? "" : "none";

      const expandRow = document.getElementById(`expand-${mat}`);
      if (expandRow) expandRow.style.display = match ? "none" : "none";
    }
  });

  [
    exchangeFilter,
    markupInput,
    hideNoPrices,
    bidAskSelect,
    fundsInput
  ].forEach(el => {
    el.addEventListener("input", renderTable);
    el.addEventListener("change", renderTable);
  });

  btn.addEventListener("click", async () => {
    status.textContent = "Loading…";

  await fetchFullCXData(status);
    loadModeledPrices();
    renderTable();
  });

// GLOBAL: stores all buying/selling orders per material per exchange
export const fullOrderData = {};

async function renderTable() {

  if (!fullCXData.length) {
    status.textContent = "No exchange data available.";
    return;
  }

  const markupPct = Number(markupInput.value) / 100;
  const filterEx = exchangeFilter.value;
  const ex = filterEx;

  const userMinVol = Number(document.getElementById("minVol").value || 0);
  const userMaxVol = Number(document.getElementById("maxVol").value || Infinity);
  const userCompany = document.getElementById("companyCode").value.trim().toUpperCase();

  // Exchanges allowed in table
  const exchangeCodes = [...new Set(fullCXData.map(r => r.ExchangeCode))]
    .sort()
    .filter(ex => filterEx === "ALL" || ex === filterEx);

  // Unique materials
  const materials = [...new Set(fullCXData.map(r => r.MaterialTicker))].sort();

  // Build header (add checkbox column)
  let headHTML = "";
  if (filterEx !== "ALL") {
    headHTML += `<th class="col-check">✔</th>`;
    headHTML += `<th class="col-info">?</th>`;
  }

   headHTML += "<th>Material</th>";

  for (const ex of exchangeCodes) headHTML += `<th>${ex}</th>`;
  headHTML += `<th>Modeled</th><th class="col-expand">Expand</th></tr>`;
  thead.innerHTML = headHTML;

  // prepare pricedata
  const showBids = bidAskSelect.value === "bids";
  const priceMap = {};
  const volumeMap = {};

  for (const row of fullCXData) {
    const ticker = row.MaterialTicker;
    const ex = row.ExchangeCode;

    if (!priceMap[ticker]) priceMap[ticker] = {};
    if (!volumeMap[ticker]) volumeMap[ticker] = {};
    if (!fullOrderData[ticker]) fullOrderData[ticker] = {};

    // fill entries:
    if (!fullOrderData[ticker][ex]) {
      fullOrderData[ticker][ex] = {
        buying: row.BuyingOrders || [],
        selling: row.SellingOrders || []
      };
    }

    let selectedPrice = null;

    if (showBids && Array.isArray(row.BuyingOrders)) {
      for (const bo of row.BuyingOrders) {
        if (typeof bo.ItemCost === "number") {
          if (selectedPrice === null || bo.ItemCost > selectedPrice)
            selectedPrice = bo.ItemCost;
        }
      }
    }

    if (!showBids && Array.isArray(row.SellingOrders)) {
      for (const so of row.SellingOrders) {
        if (typeof so.ItemCost === "number") {
          if (selectedPrice === null || so.ItemCost < selectedPrice)
            selectedPrice = so.ItemCost;
        }
      }
    }

    if (selectedPrice !== null) {
      priceMap[ticker][ex] = selectedPrice;
      volumeMap[ticker][ex] = row.VolumeAmount ?? 0;
    }
  }

  // Build body
  let bodyHTML = "";

  for (const mat of materials) {
    const modeled = modeledPrices[mat];
    const threshold = modeled ? modeled * (1 - markupPct) : null;
    const hasAnyPrice = exchangeCodes.some(ex => priceMap[mat]?.[ex] !== undefined);

    if (hideNoPrices.checked && !hasAnyPrice) continue;

    // Determine highlight & auto-check logic
    const { highlightRow, explanation } = evaluateHighlight({
      mat,
      ex,
      filterEx,
      priceMap,
      volumeMap,
      fullOrderData,
      modeled,
      threshold,
      userMinVol,
      userMaxVol,
      userCompany,
      minSpreadInput
    });

    bodyHTML += `<tr id="row-${mat}" class="${highlightRow ? "green-highlight" : ""}">`;

    // Checkbox column (checked if highlighted) and explanation column
    if (filterEx !== "ALL"){
      bodyHTML += `<td class="col-check"><input type="checkbox" class="rowCheck" data-mat="${mat}" ${highlightRow ? "checked" : ""}></td>`;
      const expl = explanation === "" ? "" : `<span class="info-icon" title="${explanation}">ℹ️</span>`;
      bodyHTML += `<td class="col-info">${expl}</td>`;
    }

    bodyHTML += `<td>${mat}</td>`;

    // draw (and highlight) individual cells for for each exchange selected
    for (const ex of exchangeCodes) {
      const p = priceMap[mat]?.[ex];
      const cellCls = filterEx == "ALL" && ( p !== undefined ? 'class="green-highlight"' : "");
      bodyHTML += `<td ${cellCls}>${p !== undefined ? p.toLocaleString() : ""}</td>`;
    }

    bodyHTML += `<td>${modeled !== undefined ? modeled.toLocaleString() : ""}</td>`;
    bodyHTML += `<td class="col-expand"><button data-mat="${mat}" class="expandBtn">Orders</button></td></tr>`;

    // Expandable row
    bodyHTML += `
    <tr id="expand-${mat}" class="expand-row" style="display:none;">
      <td colspan="${exchangeCodes.length + 4}">
        <div id="expand-content-${mat}"></div>
      </td>
    </tr>`;
  }

  tbody.innerHTML = bodyHTML;
  table.style.display = "";
  status.textContent = `Loaded ${materials.length} materials across ${exchangeCodes.length} exchanges.`;

  // Expand handlers 
  document.querySelectorAll(".expandBtn").forEach(btn => {
    btn.addEventListener("click", e => {
      addExpandContent(e, exchangeCodes, fullOrderData, userCompany)
    });
  });
}

function addExpandContent(e, exchangeCodes, fullOrderData, userCompany){
  const mat = e.target.dataset.mat;
  const row = document.getElementById(`expand-${mat}`);
  const content = document.getElementById(`expand-content-${mat}`);

  if (row.style.display === "none") {
    row.style.display = "";

    let html = `<table class="expand-details-table"><tr>`;
    for (const ex of exchangeCodes) html += `<th>${ex}</th>`;
    html += "</tr><tr>";

    for (const ex of exchangeCodes) {
      const data = fullOrderData[mat]?.[ex];
      if (!data) {
        html += "<td>(no data)</td>";
        continue;
      }

      let cell = "";

      data.selling.sort((a, b) => b.ItemCost - a.ItemCost);
      for (const so of data.selling) {
        cell += generateOrderText("sell-text", so, userCompany);
      }

      data.buying.sort((a, b) => b.ItemCost - a.ItemCost);
      for (const bo of data.buying) {
        cell += generateOrderText("buy-text", bo, userCompany);
      }

      if (cell === "") cell = "(none)";
      html += `<td>${cell}</td>`;
    }

    html += "</tr></table>";
    content.innerHTML = html;
  } else {
    row.style.display = "none";
  }
}

function generateOrderText(cssType, o, userCode){
  const count = o.ItemCount === null ? "∞" : o.ItemCount.toLocaleString();
  const cssSpan = o.CompanyCode == userCode ? "self-text" : "";
  const companyLink = `<A HREF="/intel/?co=${o.CompanyCode}" data-tooltip="${o.CompanyName}"  >${o.CompanyCode}</A>`;
  return `<div class="${cssType}">${o.ItemCost.toLocaleString()} × ${count} - <span class="${cssSpan}">${companyLink}</span></div>`;
}

function evaluateHighlight({
  mat,
  ex,
  filterEx,
  priceMap,
  volumeMap,
  fullOrderData,
  modeled,
  threshold,
  userMinVol,
  userMaxVol,
  userCompany,
  minSpreadInput
}) {
  let explanation = "";
  let highlightRow = false;

  if (filterEx === "ALL") {
    return { highlightRow, explanation };
  }

  const p = priceMap[mat]?.[ex];
  const vol = volumeMap[mat]?.[ex];

  if (p === undefined || modeled === undefined) {
    return { highlightRow, explanation };
  }

  const underModeled = p <= threshold;
  const volOK = vol >= userMinVol && vol <= userMaxVol;

  // Highest buy order
  let highestBO = null;
  const buying = fullOrderData[mat]?.[filterEx]?.buying || [];
  if (buying.length > 0) {
    highestBO = buying.reduce((a, b) => (a.ItemCost > b.ItemCost ? a : b));
  }

  // Lowest sell order
  let lowestSO = null;
  const selling = fullOrderData[mat]?.[filterEx]?.selling || [];
  if (selling.length > 0) {
    lowestSO = selling.reduce((a, b) => (a.ItemCost < b.ItemCost ? a : b));
  }

  // Spread logic
  let spreadOK = true;
  const minSpreadPct = parseFloat(minSpreadInput.value);

  if (highestBO && lowestSO && minSpreadPct > 0) {
    const spreadPct =
      (Math.abs(highestBO.ItemCost - lowestSO.ItemCost) / lowestSO.ItemCost) *
      100;

    spreadOK = spreadPct >= minSpreadPct;

    if (underModeled && !spreadOK) {
      explanation += `Spread percentage of ${spreadPct.toFixed(2)} is under target of ${minSpreadPct}.\n`;
    }
  }

  // Company already has high bid?
  const hasHighBidAlready =
    highestBO &&
    highestBO.CompanyCode?.toUpperCase() === userCompany.toUpperCase();

  // Final eligibility
  highlightRow = underModeled && volOK && !hasHighBidAlready && spreadOK;

  if (underModeled) {
    if (!volOK) {
      explanation += `Outside cash volume params: $${vol} traded is outside your $${userMinVol} .. $${userMaxVol}.\n`;
    }
    if (hasHighBidAlready) {
      explanation += `You already have high bid.\n`;
    }
  }

  return { highlightRow, explanation };
}

function makeBids() {
  const filterEx = exchangeFilter.value;
  const funds = parseFloat(fundsInput.value);
  const markupPct = parseFloat(markupInput.value); // e.g. “2” means 2%
  const checked = [...document.querySelectorAll(".rowCheck:checked")];

  if (checked.length === 0) {
    document.getElementById("bidResult").textContent = "No materials selected.";
    return;
  }

  if (!funds || funds <= 0) {
    document.getElementById("bidResult").textContent = "Enter funds first.";
    return;
  }

  const bids = [];

  // Even split funds across checked materials
  const fundsPerMaterial = funds / checked.length;
  let sum = 0;

  for (const cb of checked) {
    const mat = cb.dataset.mat;

    // Find highest BO
    
    const buying = fullOrderData[mat]?.[filterEx]?.buying || [];
    let rawPrice = 0;
    if (buying.length > 0) {
      // regular case: highest BO + markup
      const highestBO = buying.reduce((a, b) =>
        a.ItemCost > b.ItemCost ? a : b
      );
      rawPrice = highestBO.ItemCost * (1 + markupPct / 100);
    } else {
      // fallback: modeled - 20%
      const modeled = modeledPriceMap[mat];
      if (!modeled) continue;
      rawPrice = modeled * 0.8;
    }


    // Compute target price
    const targetPrice = roundToSigFigs(rawPrice, 3);

    // Determine quantity (floor) but always at least 1
    let qty = Math.floor(fundsPerMaterial / targetPrice);
    if (qty < 1) qty = 1;
    sum += qty * targetPrice;

    bids.push({
      material: mat,
      targetPrice,
      quantity: qty,
      exchange: filterEx,
    });
  }

  // Display summary (you may replace with your UI)
  document.getElementById("bidResult").textContent =
    (bids.length > 0
      ? bids.map(b => `${b.material}: ${b.quantity} @ ${b.targetPrice}`).join("\n")
      : "No bids created.")
    + `\nSum $${sum.toFixed(2)}`;

  return bids;
}


function roundToSigFigs(value, sigFigs) {
  if (value === 0) return 0;
  const digits = Math.floor(Math.log10(Math.abs(value))) + 1;
  const scale = sigFigs - digits;
  const factor = Math.pow(10, scale);
  return Math.round(value * factor) / factor;
}

document.getElementById("copyJsonBids").addEventListener("click", () => {
  const result = makeBids(); 
  if (!result || !result.bids || !Object.keys(result.bids).length) {
    alert("No bids available to convert.");
    return;
  }

  const { bids, exchange } = result;

  // bids = { MAT1: { targetPrice, qty }, MAT2: ... }

  // Assemble priceLimits (price) and materials (qty)
  const priceLimits = {};
  const materials = {};

  for (const [mat, info] of Object.entries(bids)) {
    priceLimits[mat] = info.targetPrice; // must be number
    materials[mat] = info.qty;           // must be number
  }

  // Choose a group name (user config or default)
  const groupName = "A1";

  // Final JSON output in EXACT format:
  const output = {
    actions: [
      {
        group: groupName,
        exchange: exchange,
        priceLimits: priceLimits,
        buyPartial: false,
        allowUnfilled: true,
        useCXInv: false,
        name: "buyem",
        type: "CX Buy"
      }
    ],
    global: {
      name: "OOG CX Buy Tool"
    },
    groups: [
      {
        materials: materials,
        name: groupName,
        type: "Manual"
      }
    ]
  };

  const jsonText = JSON.stringify(output);

  // Copy to clipboard
  navigator.clipboard.writeText(jsonText).then(() => {
    alert("Bid JSON copied to clipboard!");
  }).catch(err => {
    console.error("Clipboard error:", err);
    alert("Failed to copy to clipboard.");
  });
});

</script>
