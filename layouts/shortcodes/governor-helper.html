<style>
  #governor-helper-root {
    margin: 0 auto;
    text-align: left;
    padding: 1rem;
  }

  #governor-helper-root button {
    margin: 2px;
    padding: 3px 10px 3px 10px;
  }

  /* Section wrappers */
  .section-retrieved, .section-calculated {
    margin-top: 1.5rem;
    padding: 0.75rem 1rem 1rem;
    border-radius: 6px;
  }
  .section-retrieved {
    border-left: 3px solid rgb(99 102 241);
    background: rgba(99, 102, 241, 0.06);
  }
  .section-calculated {
    border-left: 3px solid rgb(16 185 129);
    background: rgba(16, 185, 129, 0.06);
  }
  .section-label {
    font-size: 0.7rem;
    font-weight: 700;
    letter-spacing: 0.1em;
    text-transform: uppercase;
    color: var(--text-secondary);
    margin-bottom: 0.75rem;
  }

  /* Side-by-side layout for infra + current needs */
  .two-col-infra {
    display: grid;
    grid-template-columns: auto 1fr;
    gap: 2rem;
    align-items: start;
  }

  /* Planet header */
  .planet-name {
    font-size: 1.25rem;
    font-weight: 700;
    margin-bottom: 0.2rem;
  }
  .planet-id {
    font-size: 1rem;
    font-weight: 400;
    color: var(--text-secondary);
    margin-left: 0.4rem;
  }
  .planet-meta {
    font-size: 0.85rem;
    color: var(--text-secondary);
    margin-bottom: 0.75rem;
  }
  .projected-meta {
    font-size: 0.65rem;
    color: var(--text-secondary);
    margin-bottom: 0.75rem;
  }

  
</style>

<div id="governor-helper-root" class="calculator">

  <div style="display:flex;gap:0.5rem;align-items:center;flex-wrap:wrap;margin-bottom:0.5rem">
    <input id="planetInput" type="text" placeholder="RC-040b or Malahat" />
    <button id="loadInfraBtn">Load Infrastructure</button>
  </div>
  <div id="warnings"></div>

  <div id="section-retrieved" class="section-retrieved" style="display:none">
    <div class="section-label">Live Data</div>
    <div id="planet-header"></div>
    <div class="two-col-infra">
      <div>
        <h3 class="mb-2 font-bold">Infrastructure Buildings</h3>
        <div id="infra-table-container"></div>
      </div>
      <div>
        <h3 class="mt-4 mb-2 font-bold">Last Population Report</h3>
        <div id="workforce-table-container"></div>
        <div style="display:flex;gap:2rem;align-items:flex-start;margin-top:1rem;flex-wrap:wrap">
          <div>
            <h3 class="mb-2 font-bold">Last Report's Need Fulfillment</h3>
            <div id="needs-table-container"></div>
          </div>
          <div class="section-calculated" style="padding:0.5rem 0.75rem">
            <div class="section-label">Projected Population Growth</div>
            <div id="projected-growth-container"></div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div id="section-calculated" class="section-calculated" style="display:none">
    <div class="section-label">Calculated</div>
    <div style="display:flex;gap:1.5rem;align-items:center;flex-wrap:wrap;margin-bottom:1rem">
      <label style="display:flex;align-items:center;gap:0.35rem;color:var(--text-secondary);font-size:0.9rem">
        Target fulfillment
        <input id="targetFulfillment" type="number" min="1" max="100" value="70" style="width:4rem" />
        %
      </label>
      <label style="display:flex;align-items:center;gap:0.35rem;color:var(--text-secondary);font-size:0.9rem">
        Supply days
        <input id="supplyDays" type="number" min="1" value="30" style="width:4rem" />
      </label>
    </div>
    <h3 class="mt-2 mb-2 font-bold">Projected Need Fulfillment</h3>
    <div id="projected-needs-container"></div>
    <h3 class="mt-6 mb-2 font-bold">Recommended Supply Plan</h3>
    <div id="supply-plan-container"></div>

    <div id="supply-export-section" style="display:none;margin-top:1.5rem">
      <h3 class="mt-2 mb-2 font-bold">Export to XIT ACTION</h3>
      <div style="display:flex;gap:1rem;align-items:center;flex-wrap:wrap;margin-bottom:0.75rem">
        <label style="display:flex;align-items:center;gap:0.35rem;color:var(--text-secondary);font-size:0.9rem">
          Origin:
          <select id="supplyOriginSelect">
            <option>Antares Station Warehouse</option>
            <option>Moria Station Warehouse</option>
            <option>Arclight Station Warehouse</option>
            <option>Benten Station Warehouse</option>
            <option>Hortus Station Warehouse</option>
            <option>Hubur Station Warehouse</option>
          </select>
          <span id="supplyOriginEmoji">ðŸ˜€</span>
        </label>
      </div>
      <textarea id="supplyJsonOutput" readonly style="width:100%;height:8rem;font-size:0.75rem;font-family:monospace;resize:vertical"></textarea>
      <br>
      <button id="supplyCopyBtn" style="margin-top:0.5rem">Copy JSON</button>
    </div>
  </div>

</div>

<script type="module">


  import { fetchPricing, fetchMaterials, priceData, materialData } from "/pricing-and-materials.js";
  import { UPKEEP_BUILDINGS, UPKEEP_NEED_TYPES, WEIGHTS } from "/infra-data.js";

const PLANET_STORAGE_KEY = "gov_helper_selected_planet";
const REFRESH_DURATION = 1 * 3600 * 1000;
const PLANET_CACHE_DURATION = 24 * 3600 * 1000;

const planetInput            = document.getElementById("planetInput");
const loadInfraBtn           = document.getElementById("loadInfraBtn");
const targetFulfillmentInput = document.getElementById("targetFulfillment");
const warnings               = document.getElementById("warnings");

// Preserved across loads so the fulfillment input can trigger recalculation
let lastRequiredNeeds  = null;
let lastLatestProjects = null;
let lastSelected       = null;
let lastReport         = null;
let lastSiteCount      = 0;
const sectionRetrieved    = document.getElementById("section-retrieved");
const sectionCalculated   = document.getElementById("section-calculated");
const planetHeaderEl      = document.getElementById("planet-header");
const infraTableCont      = document.getElementById("infra-table-container");
const needsTableCont      = document.getElementById("needs-table-container");
const workforceTableCont  = document.getElementById("workforce-table-container");
const supplyPlanCont      = document.getElementById("supply-plan-container");
const projectedNeedsCont  = document.getElementById("projected-needs-container");
const projectedGrowthCont = document.getElementById("projected-growth-container");
const supplyExportSection = document.getElementById("supply-export-section");
const supplyOriginSelect  = document.getElementById("supplyOriginSelect");
const supplyOriginEmoji   = document.getElementById("supplyOriginEmoji");
const supplyJsonOutput    = document.getElementById("supplyJsonOutput");
const supplyCopyBtn       = document.getElementById("supplyCopyBtn");

async function fetchPlanet(planetId) {
  const cacheKey = `planet_${planetId}`;
  const cached = localStorage.getItem(cacheKey);
  if (cached) {
    try {
      const { timestamp, data } = JSON.parse(cached);
      if (Date.now() - timestamp < PLANET_CACHE_DURATION) return data;
    } catch {}
  }
  const response = await fetch(`https://rest.fnar.net/planet/${planetId}`);
  if (!response.ok) throw new Error("Planet not found");
  const data = await response.json();
  localStorage.setItem(cacheKey, JSON.stringify({ timestamp: Date.now(), data }));
  return data;
}

async function fetchInfrastructure(planetId) {
  const cacheKey = `infra_${planetId}`;
  const cached = localStorage.getItem(cacheKey);

  if (cached) {
    try {
      const { timestamp, data } = JSON.parse(cached);
      if (Date.now() - timestamp < REFRESH_DURATION) {
        console.log("Loaded infrastructure from cache:", planetId);
        return data;
      }
    } catch {}
  }

  const url = `https://rest.fnar.net/infrastructure/${planetId}`;
  const response = await fetch(url);

  if (!response.ok) {
    throw new Error("Planet not found");
  }

  const data = await response.json();

  localStorage.setItem(
    cacheKey,
    JSON.stringify({
      timestamp: Date.now(),
      data,
    })
  );

  return data;
}

/**
 * Extract the entries from the largest SimulationPeriod.
 * Returns { projectMap, maxPeriod, startEpochMs }.
 */
async function fetchSiteCount(planetId) {
  const cacheKey = `sitecount_${planetId}`;
  const cached = localStorage.getItem(cacheKey);
  if (cached) {
    try {
      const { timestamp, data } = JSON.parse(cached);
      if (Date.now() - timestamp < PLANET_CACHE_DURATION) return data;
    } catch {}
  }
  const response = await fetch(
    `https://api.fnar.net/planet/sitecount?planet=${encodeURIComponent(planetId)}&include_non_player_sites=false`
  );
  if (!response.ok) return null;
  const data = await response.json();
  // API returns an array: [{ PlanetId, PlanetName, PlanetNaturalId, Count }]
  const count = Array.isArray(data) ? data[0]?.Count : null;
  if (count == null) return null;
  localStorage.setItem(cacheKey, JSON.stringify({ timestamp: Date.now(), data: count }));
  return count;
}

function extractLatestProjects(data) {
  const projects = data.InfrastructureProjects || [];
  if (!projects.length) return { projectMap: new Map(), maxPeriod: null, startEpochMs: null };

  let maxPeriod = -Infinity;
  for (const p of projects) {
    if (p.SimulationPeriod > maxPeriod) maxPeriod = p.SimulationPeriod;
  }

  const latest = projects.filter(p => p.SimulationPeriod === maxPeriod);
  const byTicker = new Map();
  for (const project of latest) {
    byTicker.set(project.Ticker, {
      level: project.Level,
      currentLevel: project.CurrentLevel,
    });
  }

  return { projectMap: byTicker, maxPeriod };
}

function formatRelativeTime(epochMs) {
  if (!epochMs) return "";
  const now = Date.now();
  let diff = epochMs - now;
  const future = diff > 0;
  diff = Math.abs(diff);
  const sec = Math.floor(diff / 1000);
  const min = Math.floor(sec / 60);
  const hr  = Math.floor(min / 60);
  const day = Math.floor(hr / 24);
  let primary = "", secondary = "";
  if (day > 0)      { primary = `${day}d`;  secondary = `${hr % 24}h`; }
  else if (hr > 0)  { primary = `${hr}h`;   secondary = `${min % 60}m`; }
  else if (min > 0) { primary = `${min}m`;  secondary = `${sec % 60}s`; }
  else              { primary = `${sec}s`; }
  const timeStr = secondary && !secondary.startsWith("0") ? `${primary} ${secondary}` : primary;
  return future ? `in ${timeStr}` : `${timeStr} ago`;
}

function getTarget() {
  const val = parseFloat(targetFulfillmentInput.value);
  return (!isNaN(val) && val >= 1 && val <= 100) ? val / 100 : 0.7;
}

function renderPlanetHeader(planetData, maxPeriod, startEpochMs, siteCount) {
  const name = planetData.PlanetName || "";
  const id   = planetData.PlanetNaturalId || "";
  const startDate = startEpochMs
    ? new Date(startEpochMs).toLocaleString(undefined, {
        year: "numeric", month: "short", day: "numeric",
        hour: "2-digit", minute: "2-digit",
      })
    : "â€”";
  const endEpochMs = startEpochMs ? startEpochMs + 7 * 24 * 3600 * 1000 : null;
  const endsIn = endEpochMs ? formatRelativeTime(endEpochMs) : "â€”";
  const basesStr = siteCount != null ? ` Â· ${siteCount} base${siteCount !== 1 ? 's' : ''}` : '';
  planetHeaderEl.innerHTML = `
    <div class="planet-name">${name}<span class="planet-id">${id}</span></div>
    <div class="planet-meta">Simulation Period ${maxPeriod ?? "â€”"} Â· Started ${startDate} Â· Ends ${endsIn}${basesStr}</div>
  `;
}

function extractLatestReport(data) {
  const reports = data.InfrastructureReports || [];
  if (!reports.length) return null;

  let latest = reports[0];

  for (const report of reports) {
    if (report.SimulationPeriod > latest.SimulationPeriod) {
      latest = report;
    }
  }

  return latest;
}


/**
 * Render infrastructure table
 */
function renderInfrastructureTable(projectMap) {
  if (!projectMap.size) return null;

  const table = document.createElement("table");
  table.className = "table-auto border-collapse text-sm";

  table.innerHTML = `
    <thead>
      <tr>
        <th class="text-left pr-4">Building</th>
        <th class="text-right pr-4">Built</th>
        <th class="text-right">Current</th>
      </tr>
    </thead>
  `;

  const tbody = document.createElement("tbody");

  const upkeepOrder = UPKEEP_BUILDINGS.map(b => b.ticker);
  const sortedTickers = [...projectMap.keys()].sort(
    (a, b) => {
      const ai = upkeepOrder.indexOf(a);
      const bi = upkeepOrder.indexOf(b);
      // Known buildings first (in UPKEEP_BUILDINGS order), unknown alphabetically after
      if (ai === -1 && bi === -1) return a.localeCompare(b);
      if (ai === -1) return 1;
      if (bi === -1) return -1;
      return ai - bi;
    }
  );

  for (const ticker of sortedTickers) {
    const { level, currentLevel } = projectMap.get(ticker);

    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td class="pr-4">${ticker}</td>
      <td class="text-right pr-4">${level}</td>
      <td class="text-right">${currentLevel}</td>
    `;

    tbody.appendChild(tr);
  }

  table.appendChild(tbody);
  return table;
}

function renderWorkforceTable(report) {
  const tiers = [
    "Pioneer",
    "Settler",
    "Technician",
    "Engineer",
    "Scientist"
  ];

  const table = document.createElement("table");
  table.className = "table-auto border-collapse text-sm mb-6";

  table.innerHTML = `
    <thead>
      <tr>
        <th class="text-left pr-4">Metric</th>
        ${tiers.map(t => `<th class="text-right pr-4">${t}</th>`).join("")}
      </tr>
    </thead>
  `;

  const tbody = document.createElement("tbody");

  const rows = [
    {
      label: "Population",
      key: "NextPopulation"
    },
    {
      label: "Change",
      key: "PopulationDifference"
    },
    {
      label: "Happiness",
      key: "AverageHappiness",
      format: v => (v * 100).toFixed(1) + "%"
    },
    {
      label: "Unemployment",
      key: "UnemploymentRate",
      format: v => (v * 100).toFixed(1) + "%"
    },
    {
      label: "Open Jobs",
      key: "OpenJobs"
    }
  ];

  for (const row of rows) {
    const tr = document.createElement("tr");

    const cells = tiers.map(tier => {
      const field = row.key + tier;
      const value = report[field];

      if (row.format) {
        return `<td class="text-right pr-4">${row.format(value)}</td>`;
      }

      return `<td class="text-right pr-4">${value.toLocaleString()}</td>`;
    });

    tr.innerHTML = `
      <td class="pr-4 font-semibold">${row.label}</td>
      ${cells.join("")}
    `;

    tbody.appendChild(tr);
  }

  table.appendChild(tbody);
  return table;
}

function renderNeedsTable(report) {
  const needs = [
    { key: "LifeSupport", label: "Life Support" },
    { key: "Safety",      label: "Safety" },
    { key: "Health",      label: "Health" },
    { key: "Comfort",     label: "Comfort" },
    { key: "Culture",     label: "Culture" },
    { key: "Education",   label: "Education" },
  ];

  const table = document.createElement("table");
  table.className = "table-auto border-collapse text-sm";

  const tbody = document.createElement("tbody");
  for (const { key, label } of needs) {
    const value = report["NeedFulfillment" + key] ?? 0;
    const pct = (value * 100).toFixed(1) + "%";
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td class="pr-4 font-semibold">${label}</td>
      <td class="text-right pr-3">${pct}</td>
    `;
    tbody.appendChild(tr);
  }
  table.appendChild(tbody);
  return table;
}


async function loadInfrastructure() {
  const planetId = planetInput.value.trim();
  if (!planetId) {
    alert("Please enter a planet identifier.");
    return;
  }

  localStorage.setItem(PLANET_STORAGE_KEY, planetId);
  const url = new URL(window.location.href);
  url.searchParams.set("planet", planetId);
  history.replaceState(null, "", url.toString());

  sectionRetrieved.style.display = "none";
  sectionCalculated.style.display = "none";
  warnings.textContent = "Loadingâ€¦";

  try {
    // Fetch pricing, planet metadata, and infrastructure data in parallel
    const [infraData, planetData, , , siteCount] = await Promise.all([
      fetchInfrastructure(planetId),
      fetchPlanet(planetId),
      fetchPricing(),
      fetchMaterials(),
      fetchSiteCount(planetId),
    ]);
    if (siteCount == null) {
      warnings.textContent = "Warning: could not retrieve base count for this planet â€” safety/health base contributions will not be included in calculations.";
    }
    lastSiteCount = siteCount ?? 0;

    const { projectMap: latestProjects, maxPeriod } = extractLatestProjects(infraData);
    const latestReport = extractLatestReport(infraData);
    const startEpochMs = latestReport.TimestampMs;

    warnings.textContent = "";

    // â”€â”€ Live Data â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    renderPlanetHeader(planetData, maxPeriod, startEpochMs, lastSiteCount);

    infraTableCont.innerHTML = "";
    const infraTable = renderInfrastructureTable(latestProjects);
    infraTableCont.appendChild(infraTable ?? Object.assign(document.createElement("p"), { textContent: "No infrastructure found." }));

    needsTableCont.innerHTML = "";
    workforceTableCont.innerHTML = "";
    lastReport = latestReport;
    if (latestReport) {
      needsTableCont.appendChild(renderNeedsTable(latestReport));
      workforceTableCont.appendChild(renderWorkforceTable(latestReport));
    }

    sectionRetrieved.style.display = "";

    // Calculated Data
    if (latestReport) {
      const population = {
        pioneer:    latestReport.NextPopulationPioneer,
        settler:    latestReport.NextPopulationSettler,
        technician: latestReport.NextPopulationTechnician,
        engineer:   latestReport.NextPopulationEngineer,
        scientist:  latestReport.NextPopulationScientist,
      };
      const requiredNeeds = calculateRequiredNeeds(population);
      lastRequiredNeeds  = requiredNeeds;
      lastLatestProjects = latestProjects;
      renderCheapestFulfillmentTable(requiredNeeds, latestProjects);
      sectionCalculated.style.display = "";
    }

  } catch (err) {
    console.error(err);
    warnings.textContent = "Failed to load: " + err.message;
  }
}

function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

// â”€â”€ Happiness weights by tier â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Source: https://pct.fnar.net/population-infrastructure/
const HAPPINESS_WEIGHTS = {
  Pioneer:    { LifeSupport: 0.54, Safety: 0.25, Health: 0.15, Comfort: 0.03, Culture: 0.02, Education: 0.01 },
  Settler:    { LifeSupport: 0.41, Safety: 0.30, Health: 0.20, Comfort: 0.03, Culture: 0.03, Education: 0.03 },
  Technician: { LifeSupport: 0.15, Safety: 0.20, Health: 0.30, Comfort: 0.20, Culture: 0.10, Education: 0.05 },
  Engineer:   { LifeSupport: 0.10, Safety: 0.10, Health: 0.15, Comfort: 0.35, Culture: 0.20, Education: 0.10 },
  Scientist:  { LifeSupport: 0.05, Safety: 0.10, Health: 0.10, Comfort: 0.20, Culture: 0.25, Education: 0.30 },
};

// Education advancement base rates (S values) â€” ENGâ†’SCI is 0 at base level
const EDU_S_BASE = {
  Pioneer_Settler:     0.020,
  Settler_Technician:  0.015,
  Technician_Engineer: 0.010,
};

// Education building bonuses per level (additive to S)
const EDU_BUILDING_BONUS = { PBH: 0.001, LIB: 0.002, UNI: 0.004 };

function renderProjectedGrowthTable(report, latestProjects, projFulfillment) {
  const TIERS = ['Pioneer', 'Settler', 'Technician', 'Engineer', 'Scientist'];

  const fulfillment = projFulfillment;

  // Population and unemployment per tier
  const pop = {};
  const unemploymentRate = {};
  for (const tier of TIERS) {
    pop[tier]              = report[`NextPopulation${tier}`]   ?? 0;
    unemploymentRate[tier] = report[`UnemploymentRate${tier}`] ?? 0;
  }

  // Two happiness values per tier (no Explorer's Grace):
  //   needHappiness = weighted need fulfillment only (before unemployment)
  //   trueHappiness = after applying unemployment penalty/bonus
  const needHappiness = {};
  const trueHappiness = {};
  for (const tier of TIERS) {
    const weights = HAPPINESS_WEIGHTS[tier];
    const needH = Object.entries(weights).reduce((s, [need, w]) => s + w * (fulfillment[need] ?? 0), 0);
    needHappiness[tier] = needH;
    const u = unemploymentRate[tier];
    let h;
    if (u >= 0) {
      h = needH - u;
    } else {
      h = needH + Math.min(-u, 0.3 * needH);
    }
    trueHappiness[tier] = Math.max(0, Math.min(1, h));
  }

  // Education S values + building bonuses
  let eduBonus = 0;
  for (const [ticker, rate] of Object.entries(EDU_BUILDING_BONUS)) {
    const proj = latestProjects.get(ticker);
    if (proj) eduBonus += (proj.level ?? 0) * rate;
  }
  const S = {
    Pioneer_Settler:     EDU_S_BASE.Pioneer_Settler     + eduBonus,
    Settler_Technician:  EDU_S_BASE.Settler_Technician  + eduBonus,
    Technician_Engineer: EDU_S_BASE.Technician_Engineer + eduBonus,
    Engineer_Scientist:  0                              + eduBonus,
  };

  // Education flows: S Ã— source population Ã— destination tier true happiness
  const edPioToSet  = S.Pioneer_Settler     * pop.Pioneer    * trueHappiness.Settler;
  const edSetToTec  = S.Settler_Technician  * pop.Settler    * trueHappiness.Technician;
  const edTecToEng  = S.Technician_Engineer * pop.Technician * trueHappiness.Engineer;
  const edEngToSci  = S.Engineer_Scientist  * pop.Engineer   * trueHappiness.Scientist;

  // Migration per tier (driven by true happiness)
  // In: PIO, SET, TEC only, when happiness > 70%
  // Out: all tiers, when happiness < 50%
  const CAN_MIGRATE_IN = new Set(['Pioneer', 'Settler', 'Technician']);
  const migIn  = {};
  const migOut = {};
  for (const tier of TIERS) {
    const h = trueHappiness[tier];
    const p = pop[tier];
    migIn[tier]  = CAN_MIGRATE_IN.has(tier) && h > 0.70 ? p * (h - 0.70) : 0;
    migOut[tier] = h < 0.50 ? 0.8 * p * (0.5 - h) : 0;
  }

  // Net components per tier
  const netMig = {
    Pioneer:    migIn.Pioneer    - migOut.Pioneer,
    Settler:    migIn.Settler    - migOut.Settler,
    Technician: migIn.Technician - migOut.Technician,
    Engineer:  -migOut.Engineer,
    Scientist: -migOut.Scientist,
  };
  const netEdu = {
    Pioneer:    -edPioToSet,
    Settler:    +edPioToSet  - edSetToTec,
    Technician: +edSetToTec  - edTecToEng,
    Engineer:   +edTecToEng  - edEngToSci,
    Scientist:  +edEngToSci,
  };

  function fmt(v) {
    const sign = v >= 0 ? '+' : '';
    const color = v >  1 ? '#4ade80'
                : v < -1 ? '#f87171'
                :           'var(--text-secondary)';
    return `<span style="color:${color}">${sign}${Math.round(v).toLocaleString()}</span>`;
  }

  const table = document.createElement('table');
  table.className = 'table-auto border-collapse text-sm';
  const thead = document.createElement('thead');
  thead.innerHTML = `
    <tr>
      <th class="text-left pr-4">Tier</th>
      <th class="text-right pr-4">Base Happy</th>
      <th class="text-right pr-4">Happiness</th>
      <th class="text-right pr-4">Migration</th>
      <th class="text-right pr-4">Education</th>
      <th class="text-right">Î” Total</th>
    </tr>
  `;
  table.appendChild(thead);
  const tbody = document.createElement('tbody');

  function hColor(h) {
    return h >= 0.70 ? '#4ade80' : h >= 0.50 ? '#fbbf24' : '#f87171';
  }

  for (const tier of TIERS) {
    if (pop[tier] === 0) continue;
    const delta  = netMig[tier] + netEdu[tier];
    const needH  = needHappiness[tier];
    const trueH  = trueHappiness[tier];
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td class="pr-4 font-semibold">${tier}</td>
      <td class="text-right pr-4" style="color:${hColor(needH)}">${(needH * 100).toFixed(1)}%</td>
      <td class="text-right pr-4" style="color:${hColor(trueH)}">${(trueH * 100).toFixed(1)}%</td>
      <td class="text-right pr-4">${fmt(netMig[tier])}</td>
      <td class="text-right pr-4">${fmt(netEdu[tier])}</td>
      <td class="text-right">${fmt(delta)}</td>
    `;
    tbody.appendChild(tr);
  }

  table.appendChild(tbody);
  return table;
}

function efficiencyColor(value) {
  value = Math.pow(value, 0.5);
  const r = value < 0.5 ? (value * 2) * 255 : 255;
  const g = value < 0.5 ? 255 : (1 - (value - 0.5) * 2) * 255;
  return `rgb(${r}, ${g}, 0, 0.3)`;
}

function calculateRequiredNeeds(pop) {
  const needs = {
    safety: 0,
    health: 0,
    comfort: 0,
    culture: 0,
    education: 0
  };

  Object.entries(pop).forEach(([tier, count]) => {
    const weights = WEIGHTS[tier];
    if (!weights) return;

    Object.entries(weights).forEach(([need, weight]) => {
      needs[need] += count * weight;
    });
  });

  return needs;
}

function computeCheapestFulfillment(requiredNeeds, latestProjects) {
  const TARGET = getTarget();

  // Each option = one (building, material) pair.
  // Quantities are stored PER LEVEL so phase 2 can freely adjust active levels.
  const allOptions = [];
  for (const building of UPKEEP_BUILDINGS) {
    const project = latestProjects.get(building.ticker);
    if (!project || !project.level) continue;
    const builtLevel = project.level;
    const n = building.materials.length;

    for (const mat of building.materials) {
      const price = priceData[mat.ticker];
      if (!price) continue;

      const contribPerLevel = {};
      for (const [need, needAmt] of Object.entries(building.needs)) {
        if (needAmt > 0) contribPerLevel[need] = needAmt / n;
      }
      if (Object.keys(contribPerLevel).length === 0) continue;

      allOptions.push({
        building: building.ticker,
        builtLevel,
        activeLevel: builtLevel, // reduced in phase 2
        ticker: mat.ticker,
        qtyPerDayPerLevel: mat.qtyPerDay,
        costPerLevel: mat.qtyPerDay * price,
        contribPerLevel,
      });
    }
  }

  // â”€â”€ Phase 1: greedy material selection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Cost-effectiveness = contribPerLevel / costPerLevel (level cancels out),
  // so material ranking is independent of how many levels are active.
  // Each base provides 50 safety and 50 health (fixed, independent of infra buildings)
  const baseContrib = lastSiteCount * 50;

  const selected = new Set();
  const remaining = {};
  for (const [need, req] of Object.entries(requiredNeeds)) {
    remaining[need] = req * TARGET;
  }
  // Subtract base contributions so optimizer only selects what buildings still need to cover
  if (remaining.safety !== undefined) remaining.safety -= baseContrib;
  if (remaining.health !== undefined) remaining.health -= baseContrib;

  for (const need of Object.keys(requiredNeeds)) {
    // Credit already-selected materials at their full built level
    for (const idx of selected) {
      remaining[need] -= (allOptions[idx].contribPerLevel[need] ?? 0) * allOptions[idx].builtLevel;
    }
    if (remaining[need] <= 0) continue;

    const candidates = allOptions
      .map((opt, i) => ({ opt, i }))
      .filter(({ i }) => !selected.has(i))
      .filter(({ opt }) => (opt.contribPerLevel[need] ?? 0) > 0)
      .sort(({ opt: a }, { opt: b }) =>
        b.contribPerLevel[need] / b.costPerLevel - a.contribPerLevel[need] / a.costPerLevel
      );

    for (const { opt, i } of candidates) {
      if (remaining[need] <= 0) break;
      selected.add(i);
      // Apply all contributions so cross-need buildings aren't double-purchased
      for (const [n2, c] of Object.entries(opt.contribPerLevel)) {
        remaining[n2] = (remaining[n2] ?? 0) - c * opt.builtLevel;
      }
    }
  }

  if (selected.size === 0) return [];

  // â”€â”€ Phase 2: minimize active levels to avoid overshooting â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Compute surplus over target at full built levels (include base contrib).
  const provided = { safety: baseContrib, health: baseContrib };
  for (const idx of selected) {
    for (const [need, c] of Object.entries(allOptions[idx].contribPerLevel)) {
      provided[need] = (provided[need] ?? 0) + c * allOptions[idx].builtLevel;
    }
  }
  const surplus = {};
  for (const [need, req] of Object.entries(requiredNeeds)) {
    surplus[need] = (provided[need] ?? 0) - req * TARGET;
  }

  // Aggregate per-building totals for the reduction pass
  const bldMap = new Map();
  for (const idx of selected) {
    const opt = allOptions[idx];
    if (!bldMap.has(opt.building)) {
      bldMap.set(opt.building, { indices: [], builtLevel: opt.builtLevel, costPerLvl: 0, contribPerLvl: {} });
    }
    const e = bldMap.get(opt.building);
    e.indices.push(idx);
    e.costPerLvl += opt.costPerLevel;
    for (const [need, c] of Object.entries(opt.contribPerLevel)) {
      e.contribPerLvl[need] = (e.contribPerLvl[need] ?? 0) + c;
    }
  }

  // Reduce most-expensive buildings first to maximise savings
  const sortedBlds = [...bldMap.values()].sort((a, b) => b.costPerLvl - a.costPerLvl);

  for (const bData of sortedBlds) {
    let maxReduce = bData.builtLevel;
    for (const [need, c] of Object.entries(bData.contribPerLvl)) {
      if (c <= 0) continue;
      maxReduce = Math.min(maxReduce, Math.floor(surplus[need] / c));
    }
    maxReduce = Math.max(0, maxReduce);

    // Update surplus to reflect the reduction before processing next building
    for (const [need, c] of Object.entries(bData.contribPerLvl)) {
      surplus[need] -= maxReduce * c;
    }
    const newActive = bData.builtLevel - maxReduce;
    for (const idx of bData.indices) allOptions[idx].activeLevel = newActive;
  }

  // â”€â”€ Return final plan â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  return [...selected]
    .filter(i => allOptions[i].activeLevel > 0) // drop fully deactivated buildings
    .map(i => {
      const opt = allOptions[i];
      const a = opt.activeLevel;
      return {
        building: opt.building,
        builtLevel: opt.builtLevel,
        activeLevel: a,
        ticker: opt.ticker,
        qtyPerDay: opt.qtyPerDayPerLevel * a,
        cost: opt.costPerLevel * a,
        contributions: Object.fromEntries(
          Object.entries(opt.contribPerLevel).map(([k, v]) => [k, v * a])
        ),
      };
    });
}

function renderCheapestFulfillmentTable(requiredNeeds, latestProjects) {
  supplyPlanCont.innerHTML = "";
  projectedNeedsCont.innerHTML = "";

  const selected = computeCheapestFulfillment(requiredNeeds, latestProjects);

  if (selected.length === 0) {
    // Diagnose exactly why nothing was selected
    const presentBuildings = UPKEEP_BUILDINGS.filter(b => {
      const p = latestProjects.get(b.ticker);
      return p && p.level > 0;
    });

    const reasons = [];

    if (presentBuildings.length === 0) {
      reasons.push("No infrastructure buildings are present on this planet yet.");
    } else {
      const missingPrices = new Set();
      for (const b of presentBuildings) {
        for (const mat of b.materials) {
          if (!priceData[mat.ticker]) missingPrices.add(mat.ticker);
        }
      }
      if (missingPrices.size > 0) {
        reasons.push(`Market prices are missing for: ${[...missingPrices].sort().join(", ")}. Prices may still be loading â€” try again in a moment.`);
      }
      if (missingPrices.size === 0) {
        reasons.push("All buildings have prices but no material contributes to the outstanding needs. This is unexpected â€” please report it.");
      }
    }

    const msg = document.createElement("p");
    msg.style.color = "#f87171";
    msg.textContent = "No supply plan could be calculated. " + reasons.join(" ");
    supplyPlanCont.appendChild(msg);
    return;
  }

  // Compute totals for the summary (include base safety/health from player bases)
  const provided = { safety: lastSiteCount * 50, health: lastSiteCount * 50 };
  let totalCost = 0;
  for (const opt of selected) {
    totalCost += opt.cost;
    for (const [need, contrib] of Object.entries(opt.contributions)) {
      provided[need] = (provided[need] || 0) + contrib;
    }
  }

  // --- Supply plan table grouped by building ---
  const byBuilding = new Map();
  for (const opt of selected) {
    if (!byBuilding.has(opt.building)) byBuilding.set(opt.building, []);
    byBuilding.get(opt.building).push(opt);
  }

  const planTable = document.createElement("table");
  planTable.className = "infra-table";
  const planHead = document.createElement("thead");
  planHead.innerHTML = `
    <tr>
      <th>Building</th>
      <th>Material</th>
      <th class="text-right">Qty / Day</th>
      <th class="text-right">Daily Cost</th>
      <th>Needs Supplied</th>
      <th class="text-right">Need Qty</th>
      <th class="text-right">$ / Need</th>
    </tr>
  `;
  planTable.appendChild(planHead);

  // Pre-compute $/need for each option so we can normalise for coloring
  const allSelected = [...byBuilding.values()].flat();
  const dollarPerNeed = opt => {
    const totalNeed = Object.values(opt.contributions).reduce((s, v) => s + v, 0);
    return totalNeed > 0 ? opt.cost / totalNeed : Infinity;
  };
  const dpnValues = allSelected.map(dollarPerNeed).filter(v => isFinite(v));
  const dpnMin = Math.min(...dpnValues);
  const dpnMax = Math.max(...dpnValues);
  const dpnRange = dpnMax - dpnMin || 1;

  const planBody = document.createElement("tbody");
  for (const [building, opts] of byBuilding) {
    for (const opt of opts) {
      const needNames = Object.keys(opt.contributions).map(capitalize).join(", ");
      const needQtys = Object.values(opt.contributions)
        .map(v => v.toLocaleString(undefined, { maximumFractionDigits: 1 }))
        .join(", ");
      const dpn = dollarPerNeed(opt);
      const norm = isFinite(dpn) ? (dpn - dpnMin) / dpnRange : 1; // 0 = best, 1 = worst
      const rowColor = efficiencyColor(norm);
      const tr = document.createElement("tr");
      tr.style.backgroundColor = rowColor;
      tr.innerHTML = `
        <td>${opt.activeLevel < opt.builtLevel
          ? `<span style="color:#4ade80;font-weight:600">${opt.activeLevel}</span><span style="color:var(--text-secondary)">/${opt.builtLevel}</span> ${building}`
          : `${opt.activeLevel} ${building}`
        }</td>
        <td>${opt.ticker}</td>
        <td class="text-right">${opt.qtyPerDay.toLocaleString(undefined, { maximumFractionDigits: 2 })}</td>
        <td class="text-right">${opt.cost.toLocaleString(undefined, { maximumFractionDigits: 2 })}</td>
        <td>${needNames}</td>
        <td class="text-right">${needQtys}</td>
        <td class="text-right">${isFinite(dpn) ? dpn.toFixed(4) : "â€”"}</td>
      `;
      planBody.appendChild(tr);
    }
  }
  const totalRow = document.createElement("tr");
  totalRow.innerHTML = `
    <td colspan="6" class="font-semibold text-right">Total daily cost</td>
    <td class="text-right font-semibold">${totalCost.toLocaleString(undefined, { maximumFractionDigits: 2 })}</td>
  `;
  planBody.appendChild(totalRow);
  planTable.appendChild(planBody);
  supplyPlanCont.appendChild(planTable);

  // --- Supply period summary (weight, volume, cost) ---
  const supplyDays = parseFloat(document.getElementById("supplyDays").value) || 30;
  let periodWeight = 0;
  let periodVolume = 0;
  for (const opt of selected) {
    const qty = opt.qtyPerDay * supplyDays;
    const matInfo = materialData[opt.ticker] || {};
    periodWeight += qty * (matInfo.weight || 0);
    periodVolume += qty * (matInfo.volume || 0);
  }
  const periodCost = totalCost * supplyDays;

  const summaryDiv = document.createElement("div");
  summaryDiv.style.cssText = "margin-top:0.75rem;font-size:0.9rem;color:var(--text-secondary);display:flex;gap:1.5rem;flex-wrap:wrap";
  summaryDiv.innerHTML = `
    <span>Supply period cost: <strong style="color:var(--text-primary)">${periodCost.toLocaleString(undefined, { maximumFractionDigits: 0 })}</strong></span>
    <span>Weight: <strong style="color:var(--text-primary)">${periodWeight.toLocaleString(undefined, { maximumFractionDigits: 1 })} t</strong></span>
    <span>Volume: <strong style="color:var(--text-primary)">${periodVolume.toLocaleString(undefined, { maximumFractionDigits: 1 })} mÂ³</strong></span>
  `;
  supplyPlanCont.appendChild(summaryDiv);

  // --- Need fulfillment summary ---
  const NEED_ORDER = ["safety", "health", "comfort", "culture", "education"];

  const summaryTable = document.createElement("table");
  summaryTable.className = "infra-table";
  const summaryHead = document.createElement("thead");
  summaryHead.innerHTML = `
    <tr>
      <th>Need</th>
      <th class="text-right">Required</th>
      <th class="text-right">Provided</th>
      <th class="text-right">Fulfillment</th>
      <th class="text-right">Status</th>
    </tr>
  `;
  summaryTable.appendChild(summaryHead);

  const summaryBody = document.createElement("tbody");
  for (const need of NEED_ORDER) {
    const req = requiredNeeds[need] || 0;
    const prov = provided[need] || 0;
    const fulfillment = req > 0 ? prov / req : 1;
    const met = fulfillment >= getTarget();

    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${capitalize(need)}</td>
      <td class="text-right">${req.toLocaleString(undefined, { maximumFractionDigits: 1 })}</td>
      <td class="text-right">${prov.toLocaleString(undefined, { maximumFractionDigits: 1 })}</td>
      <td class="text-right">${(fulfillment * 100).toFixed(1)}%</td>
      <td class="text-right" style="color:${met ? "#4ade80" : "#f87171"}">${met ? "âœ“" : "âœ—"}</td>
    `;
    summaryBody.appendChild(tr);
  }
  summaryTable.appendChild(summaryBody);
  projectedNeedsCont.appendChild(summaryTable);

  // Store and render export
  lastSelected = selected;
  updateSupplyExport();

  // Rerender projected growth using projected fulfillment from this plan
  if (lastReport && lastLatestProjects) {
    const pf = need => requiredNeeds[need] > 0
      ? Math.min(1, (provided[need] || 0) / requiredNeeds[need])
      : (lastReport[`NeedFulfillment${need.charAt(0).toUpperCase() + need.slice(1)}`] ?? 0);
    const projFulfillment = {
      LifeSupport: lastReport.NeedFulfillmentLifeSupport ?? 0,
      Safety:      pf('safety'),
      Health:      pf('health'),
      Comfort:     pf('comfort'),
      Culture:     pf('culture'),
      Education:   pf('education'),
    };
    projectedGrowthCont.innerHTML = `<div class="projected-meta">Projected happiness with each need at ${getTarget() * 100}%. <br/>Base Happy does not include unemployment, but "Happiness" does.</div>`;
    projectedGrowthCont.appendChild(
      renderProjectedGrowthTable(lastReport, lastLatestProjects, projFulfillment)
    );
  }
}

// â”€â”€ XIT ACTION export â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const CX_MAP = {
  "Antares Station Warehouse": "AI1",
  "Moria Station Warehouse":   "NC1",
  "Arclight Station Warehouse":"CI2",
  "Benten Station Warehouse":  "CI1",
  "Hortus Station Warehouse":  "IC1",
  "Hubur Station Warehouse":   "NC2",
};

function updateSupplyExport() {
  if (!lastSelected || !lastSelected.length) {
    supplyExportSection.style.display = "none";
    return;
  }

  const supplyDays = parseFloat(document.getElementById("supplyDays").value) || 30;
  const origin = supplyOriginSelect.value;

  // Aggregate qty per ticker across all selected building/material pairs
  const materials = {};
  for (const opt of lastSelected) {
    const qty = Math.ceil(opt.qtyPerDay * supplyDays);
    if (qty > 0) materials[opt.ticker] = (materials[opt.ticker] || 0) + qty;
  }

  const exportJson = {
    actions: [
      {
        group: "Items",
        exchange: CX_MAP[origin] || "NC1",
        priceLimits: {},
        buyPartial: false,
        useCXInv: true,
        name: "BuyItems",
        type: "CX Buy",
      },
      {
        type: "MTRA",
        name: "TransferAction",
        group: "Items",
        origin,
        dest: "Configure on Execution",
      },
    ],
    global: { name: "OOG Governor Supply Plan" },
    groups: [{ type: "Manual", name: "Items", materials }],
  };

  supplyJsonOutput.value = JSON.stringify(exportJson, null, 2);
  supplyOriginEmoji.textContent = origin === "Antares Station Warehouse" ? "ðŸ˜€" : "ðŸ˜¢";
  supplyExportSection.style.display = "";
}

supplyCopyBtn.addEventListener("click", () => {
  navigator.clipboard.writeText(supplyJsonOutput.value).then(() => {
    supplyCopyBtn.textContent = "Copied!";
    setTimeout(() => (supplyCopyBtn.textContent = "Copy JSON"), 1500);
  });
});

loadInfraBtn.addEventListener("click", loadInfrastructure);

targetFulfillmentInput.addEventListener("input", () => {
  if (lastRequiredNeeds && lastLatestProjects && sectionCalculated.style.display !== "none") {
    renderCheapestFulfillmentTable(lastRequiredNeeds, lastLatestProjects);
  }
});

document.getElementById("supplyDays").addEventListener("input", updateSupplyExport);
supplyOriginSelect.addEventListener("input", updateSupplyExport);

document.addEventListener("DOMContentLoaded", async () => {
  // URL param takes priority; fall back to last-used planet from localStorage
  const urlPlanet = new URL(window.location.href).searchParams.get("planet");
  const savedPlanet = urlPlanet || localStorage.getItem(PLANET_STORAGE_KEY);

  if (savedPlanet) {
    planetInput.value = savedPlanet;
    if (urlPlanet) {
      // Auto-load when planet is specified in the URL
      await loadInfrastructure();
    }
  }
});



</script>