<style>
  #governor-helper-root {
    margin: 0 auto;
    text-align: left;
    padding: 1rem;
  }

  #governor-helper-root button {
    margin: 2px;
    padding: 3px 10px 3px 10px;
  }
</style>

<div id="governor-helper-root"  class="calculator">

  <input id="planetInput" type="text" placeholder="RC-040b or Malahat" />
  <button id="loadInfraBtn">Load Infrastructure</button>
  <div id="warnings"></div>
  <div id="infraTableContainer"></div>
</div>

<script type="module">


  import { fetchPricing, priceData } from "/pricing-and-materials.js";
  import { UPKEEP_BUILDINGS, UPKEEP_NEED_TYPES, WEIGHTS } from "/infra-data.js";

const PLANET_STORAGE_KEY = "gov_helper_selected_planet";

const REFRESH_DURATION = 1 * 3600 * 1000;

const planetInput = document.getElementById("planetInput");
const loadInfraBtn = document.getElementById("loadInfraBtn");
const tableContainer = document.getElementById("infraTableContainer");
const warnings = document.getElementById("warnings");

/**
 * Fetch infrastructure for a planet with 2-week caching
 */
async function fetchInfrastructure(planetId) {
  const cacheKey = `infra_${planetId}`;
  const cached = localStorage.getItem(cacheKey);

  if (cached) {
    try {
      const { timestamp, data } = JSON.parse(cached);
      if (Date.now() - timestamp < REFRESH_DURATION) {
        console.log("Loaded infrastructure from cache:", planetId);
        return data;
      }
    } catch {}
  }

  const url = `https://rest.fnar.net/infrastructure/${planetId}`;
  const response = await fetch(url);

  if (!response.ok) {
    throw new Error("Planet not found");
  }

  const data = await response.json();

  localStorage.setItem(
    cacheKey,
    JSON.stringify({
      timestamp: Date.now(),
      data,
    })
  );

  return data;
}

/**
 * Extract only the entries from the largest SimulationPeriod
 * and return a Map keyed by ticker
 */
function extractLatestProjects(data) {
  const projects = data.InfrastructureProjects || [];
  if (!projects.length) return new Map();

  // Find max SimulationPeriod
  let maxPeriod = -Infinity;
  for (const p of projects) {
    if (p.SimulationPeriod > maxPeriod) {
      maxPeriod = p.SimulationPeriod;
    }
  }

  // Filter only that period
  const latest = projects.filter(
    (p) => p.SimulationPeriod === maxPeriod
  );

  // Deduplicate by ticker (in case duplicates exist)
  const byTicker = new Map();

  for (const project of latest) {
    byTicker.set(project.Ticker, {
      level: project.Level,
      currentLevel: project.CurrentLevel,
    });
  }

  return byTicker;
}

function extractLatestReport(data) {
  const reports = data.InfrastructureReports || [];
  if (!reports.length) return null;

  let latest = reports[0];

  for (const report of reports) {
    if (report.SimulationPeriod > latest.SimulationPeriod) {
      latest = report;
    }
  }

  return latest;
}


/**
 * Render infrastructure table
 */
function renderInfrastructureTable(projectMap) {
  tableContainer.innerHTML = "";

  if (!projectMap.size) {
    tableContainer.textContent = "No infrastructure found.";
    return;
  }

  const table = document.createElement("table");
  table.className = "table-auto border-collapse text-sm";

  table.innerHTML = `
    <thead>
      <tr>
        <th class="text-left pr-4">Ticker</th>
        <th class="text-right pr-4">Level</th>
        <th class="text-right">Current Level</th>
      </tr>
    </thead>
  `;

  const tbody = document.createElement("tbody");

  const upkeepOrder = UPKEEP_BUILDINGS.map(b => b.ticker);
  const sortedTickers = [...projectMap.keys()].sort(
    (a, b) => {
      const ai = upkeepOrder.indexOf(a);
      const bi = upkeepOrder.indexOf(b);
      // Known buildings first (in UPKEEP_BUILDINGS order), unknown alphabetically after
      if (ai === -1 && bi === -1) return a.localeCompare(b);
      if (ai === -1) return 1;
      if (bi === -1) return -1;
      return ai - bi;
    }
  );

  for (const ticker of sortedTickers) {
    const { level, currentLevel } = projectMap.get(ticker);

    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td class="pr-4">${ticker}</td>
      <td class="text-right pr-4">${level}</td>
      <td class="text-right">${currentLevel}</td>
    `;

    tbody.appendChild(tr);
  }

  table.appendChild(tbody);
  return table;
}

function renderWorkforceTable(report) {
  const tiers = [
    "Pioneer",
    "Settler",
    "Technician",
    "Engineer",
    "Scientist"
  ];

  const table = document.createElement("table");
  table.className = "table-auto border-collapse text-sm mb-6";

  table.innerHTML = `
    <thead>
      <tr>
        <th class="text-left pr-4">Metric</th>
        ${tiers.map(t => `<th class="text-right pr-4">${t}</th>`).join("")}
      </tr>
    </thead>
  `;

  const tbody = document.createElement("tbody");

  const rows = [
    {
      label: "Population",
      key: "NextPopulation"
    },
    {
      label: "Change",
      key: "PopulationDifference"
    },
    {
      label: "Happiness",
      key: "AverageHappiness",
      format: v => (v * 100).toFixed(1) + "%"
    },
    {
      label: "Unemployment",
      key: "UnemploymentRate",
      format: v => (v * 100).toFixed(1) + "%"
    },
    {
      label: "Open Jobs",
      key: "OpenJobs"
    }
  ];

  for (const row of rows) {
    const tr = document.createElement("tr");

    const cells = tiers.map(tier => {
      const field = row.key + tier;
      const value = report[field];

      if (row.format) {
        return `<td class="text-right pr-4">${row.format(value)}</td>`;
      }

      return `<td class="text-right pr-4">${value.toLocaleString()}</td>`;
    });

    tr.innerHTML = `
      <td class="pr-4 font-semibold">${row.label}</td>
      ${cells.join("")}
    `;

    tbody.appendChild(tr);
  }

  table.appendChild(tbody);
  return table;
}

function renderNeedsTable(report) {
  const needs = [
    "LifeSupport",
    "Safety",
    "Health",
    "Comfort",
    "Culture",
    "Education"
  ];

  const table = document.createElement("table");
  table.className = "table-auto border-collapse text-sm";

  table.innerHTML = `
    <thead>
      <tr>
        ${needs.map(n => `<th class="text-right pr-4">${n}</th>`).join("")}
      </tr>
    </thead>
  `;

  const tbody = document.createElement("tbody");

  const tr = document.createElement("tr");

  tr.innerHTML = needs
    .map(need => {
      const value = report["NeedFulfillment" + need];
      const percent = (value * 100).toFixed(1) + "%";
      return `<td class="text-right pr-4">${percent}</td>`;
    })
    .join("");

  tbody.appendChild(tr);
  table.appendChild(tbody);

  return table;
}


/**
 * Main handler
 */
async function loadInfrastructure() {
  const planetId = planetInput.value.trim();

  if (!planetId) {
    alert("Please enter a planet identifier.");
    return;
  }

  localStorage.setItem(PLANET_STORAGE_KEY, planetId);

  // Reflect planet in the URL so the page is shareable / bookmarkable
  const url = new URL(window.location.href);
  url.searchParams.set("planet", planetId);
  history.replaceState(null, "", url.toString());

  tableContainer.innerHTML = "Loading...";

  await fetchPricing();

  try {
    const data = await fetchInfrastructure(planetId);

    const latestProjects = extractLatestProjects(data);
    const latestReport = extractLatestReport(data);

    tableContainer.innerHTML = "";

    // Infrastructure Projects Table
    const infraTable = renderInfrastructureTable(latestProjects);
    tableContainer.appendChild(infraTable);

    if (latestReport) {

      const population = {
        pioneer: latestReport.NextPopulationPioneer,
        settler: latestReport.NextPopulationSettler,
        technician: latestReport.NextPopulationTechnician,
        engineer: latestReport.NextPopulationEngineer,
        scientist: latestReport.NextPopulationScientist
      };

      const workforceTitle = document.createElement("h3");
      workforceTitle.textContent = "Workforce Status";
      workforceTitle.className = "mt-6 mb-2 font-bold";
      tableContainer.appendChild(workforceTitle);

      tableContainer.appendChild(renderWorkforceTable(latestReport));

      const needsTitle = document.createElement("h3");
      needsTitle.textContent = "Need Fulfillment";
      needsTitle.className = "mt-6 mb-2 font-bold";
      tableContainer.appendChild(needsTitle);

      tableContainer.appendChild(renderNeedsTable(latestReport));

      const requiredNeeds = renderRequiredNeedsTable(population);

      renderCheapestFulfillmentTable(requiredNeeds, latestProjects);

    }

  } catch (err) {
    console.error(err);
    tableContainer.textContent = "Failed to load infrastructure. " + err;
  }
}

function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

function efficiencyColor(value) {
  value = Math.pow(value, 0.5);
  const r = value < 0.5 ? (value * 2) * 255 : 255;
  const g = value < 0.5 ? 255 : (1 - (value - 0.5) * 2) * 255;
  return `rgb(${r}, ${g}, 0, 0.3)`;
}

function calculateRequiredNeeds(pop) {
  const needs = {
    safety: 0,
    health: 0,
    comfort: 0,
    culture: 0,
    education: 0
  };

  Object.entries(pop).forEach(([tier, count]) => {
    const weights = WEIGHTS[tier];
    if (!weights) return;

    Object.entries(weights).forEach(([need, weight]) => {
      needs[need] += count * weight;
    });
  });

  return needs;
}

function renderRequiredNeedsTable(population) {
  if (!population) return;

  const required = calculateRequiredNeeds(population);

  const NEED_ORDER = ["safety", "health", "comfort", "culture", "education"];

  const table = document.createElement("table");
  table.className = "infra-table";

  // Header
  const thead = document.createElement("thead");
  const headRow = document.createElement("tr");
  headRow.innerHTML = `
    <th>Need</th>
    ${NEED_ORDER.map(n => `<th>${capitalize(n)}</th>`).join("")}
  `;
  thead.appendChild(headRow);
  table.appendChild(thead);

  // Values row
  const tbody = document.createElement("tbody");
  const row = document.createElement("tr");

  row.innerHTML = `
    <td>Required</td>
    ${NEED_ORDER.map(n => `<td>${required[n].toLocaleString(undefined, { maximumFractionDigits: 2 })}</td>`).join("")}
  `;

  tbody.appendChild(row);
  table.appendChild(tbody);

  tableContainer.appendChild(table);

  return required; // Important: reuse later
}

// -------------
function computeExistingNeedCapacity(latestProjects) {
  const capacity = {
    safety: 0,
    health: 0,
    comfort: 0,
    culture: 0,
    education: 0
  };

  for (const building of UPKEEP_BUILDINGS) {
    const project = latestProjects.get(building.ticker);
    if (!project) continue;

    const levels = project.level || 0;

    for (const need of Object.keys(capacity)) {
      capacity[need] += (building.needs[need] || 0) * levels;
    }
  }

  return capacity;
}

function computeCheapestFulfillment(requiredNeeds, latestProjects) {
  const TARGET = 0.7;

  // Build one candidate per (building, material) for each present building.
  // Each material independently provides 1/n of its building's need output,
  // where n = total number of materials the building consumes.
  const allOptions = [];
  for (const building of UPKEEP_BUILDINGS) {
    const project = latestProjects.get(building.ticker);
    if (!project || !project.level) continue;
    const levels = project.level;
    const n = building.materials.length;

    for (const mat of building.materials) {
      const price = priceData[mat.ticker];
      if (!price) continue;

      const contributions = {};
      for (const [need, needAmt] of Object.entries(building.needs)) {
        if (needAmt > 0) contributions[need] = (needAmt / n) * levels;
      }
      if (Object.keys(contributions).length === 0) continue;

      allOptions.push({
        building: building.ticker,
        levels,
        ticker: mat.ticker,
        qtyPerDay: mat.qtyPerDay * levels,
        cost: mat.qtyPerDay * price * levels,
        contributions,
      });
    }
  }

  const selected = new Set(); // indices into allOptions

  // Remaining need to satisfy (starts at 70% of required for each category)
  const remaining = {};
  for (const [need, req] of Object.entries(requiredNeeds)) {
    remaining[need] = req * TARGET;
  }

  // Solve each need type independently with a greedy pass:
  // pick the unselected material that provides the most of this need per dollar.
  // When a material is selected, apply ALL its contributions so cross-need
  // buildings (e.g. EMC covering safety + health) don't get double-purchased.
  for (const need of Object.keys(requiredNeeds)) {
    // Credit contributions from materials already selected for prior needs
    for (const idx of selected) {
      const contrib = allOptions[idx].contributions[need];
      if (contrib) remaining[need] -= contrib;
    }
    if (remaining[need] <= 0) continue;

    // Sort unselected candidates for this need by need-per-dollar (descending)
    const candidates = allOptions
      .map((opt, i) => ({ opt, i }))
      .filter(({ opt, i }) => !selected.has(i) && (opt.contributions[need] ?? 0) > 0)
      .sort(
        ({ opt: a }, { opt: b }) =>
          b.contributions[need] / b.cost - a.contributions[need] / a.cost
      );

    for (const { opt, i } of candidates) {
      if (remaining[need] <= 0) break;
      selected.add(i);
      // Apply all contributions from this material (handles cross-need buildings)
      for (const [n2, contrib] of Object.entries(opt.contributions)) {
        remaining[n2] = (remaining[n2] ?? 0) - contrib;
      }
    }
  }

  return [...selected].map(i => allOptions[i]);
}

function renderCheapestFulfillmentTable(requiredNeeds, latestProjects) {
  const selected = computeCheapestFulfillment(requiredNeeds, latestProjects);

  const planTitle = document.createElement("h3");
  planTitle.textContent = "Recommended Supply Plan";
  planTitle.className = "mt-6 mb-2 font-bold";
  tableContainer.appendChild(planTitle);

  if (selected.length === 0) {
    // Diagnose exactly why nothing was selected
    const presentBuildings = UPKEEP_BUILDINGS.filter(b => {
      const p = latestProjects.get(b.ticker);
      return p && p.level > 0;
    });

    const reasons = [];

    if (presentBuildings.length === 0) {
      reasons.push("No infrastructure buildings are present on this planet yet.");
    } else {
      const missingPrices = new Set();
      for (const b of presentBuildings) {
        for (const mat of b.materials) {
          if (!priceData[mat.ticker]) missingPrices.add(mat.ticker);
        }
      }
      if (missingPrices.size > 0) {
        reasons.push(`Market prices are missing for: ${[...missingPrices].sort().join(", ")}. Prices may still be loading — try again in a moment.`);
      }
      if (missingPrices.size === 0) {
        reasons.push("All buildings have prices but no material contributes to the outstanding needs. This is unexpected — please report it.");
      }
    }

    const msg = document.createElement("p");
    msg.style.color = "#f87171";
    msg.textContent = "No supply plan could be calculated. " + reasons.join(" ");
    tableContainer.appendChild(msg);
    return;
  }

  // Compute totals for the summary
  const provided = {};
  let totalCost = 0;
  for (const opt of selected) {
    totalCost += opt.cost;
    for (const [need, contrib] of Object.entries(opt.contributions)) {
      provided[need] = (provided[need] || 0) + contrib;
    }
  }

  // --- Supply plan table grouped by building ---
  const byBuilding = new Map();
  for (const opt of selected) {
    if (!byBuilding.has(opt.building)) byBuilding.set(opt.building, []);
    byBuilding.get(opt.building).push(opt);
  }

  const planTable = document.createElement("table");
  planTable.className = "infra-table";
  const planHead = document.createElement("thead");
  planHead.innerHTML = `
    <tr>
      <th>Building</th>
      <th>Material</th>
      <th class="text-right">Qty / Day</th>
      <th class="text-right">Daily Cost</th>
      <th>Needs Supplied</th>
      <th class="text-right">Need Qty</th>
      <th class="text-right">$ / Need</th>
    </tr>
  `;
  planTable.appendChild(planHead);

  // Pre-compute $/need for each option so we can normalise for coloring
  const allSelected = [...byBuilding.values()].flat();
  const dollarPerNeed = opt => {
    const totalNeed = Object.values(opt.contributions).reduce((s, v) => s + v, 0);
    return totalNeed > 0 ? opt.cost / totalNeed : Infinity;
  };
  const dpnValues = allSelected.map(dollarPerNeed).filter(v => isFinite(v));
  const dpnMin = Math.min(...dpnValues);
  const dpnMax = Math.max(...dpnValues);
  const dpnRange = dpnMax - dpnMin || 1;

  const planBody = document.createElement("tbody");
  for (const [building, opts] of byBuilding) {
    for (const opt of opts) {
      const needNames = Object.keys(opt.contributions).map(capitalize).join(", ");
      const needQtys = Object.values(opt.contributions)
        .map(v => v.toLocaleString(undefined, { maximumFractionDigits: 1 }))
        .join(", ");
      const dpn = dollarPerNeed(opt);
      const norm = isFinite(dpn) ? (dpn - dpnMin) / dpnRange : 1; // 0 = best, 1 = worst
      const rowColor = efficiencyColor(norm);
      const tr = document.createElement("tr");
      tr.style.backgroundColor = rowColor;
      tr.innerHTML = `
        <td>${opt.levels}x ${building}</td>
        <td>${opt.ticker}</td>
        <td class="text-right">${opt.qtyPerDay.toLocaleString(undefined, { maximumFractionDigits: 2 })}</td>
        <td class="text-right">${opt.cost.toLocaleString(undefined, { maximumFractionDigits: 2 })}</td>
        <td>${needNames}</td>
        <td class="text-right">${needQtys}</td>
        <td class="text-right">${isFinite(dpn) ? dpn.toFixed(4) : "—"}</td>
      `;
      planBody.appendChild(tr);
    }
  }
  const totalRow = document.createElement("tr");
  totalRow.innerHTML = `
    <td colspan="6" class="font-semibold text-right">Total daily cost</td>
    <td class="text-right font-semibold">${totalCost.toLocaleString(undefined, { maximumFractionDigits: 2 })}</td>
  `;
  planBody.appendChild(totalRow);
  planTable.appendChild(planBody);
  tableContainer.appendChild(planTable);

  // --- Need fulfillment summary ---
  const NEED_ORDER = ["safety", "health", "comfort", "culture", "education"];

  const summaryTitle = document.createElement("h3");
  summaryTitle.textContent = "Projected Need Fulfillment";
  summaryTitle.className = "mt-6 mb-2 font-bold";
  tableContainer.appendChild(summaryTitle);

  const summaryTable = document.createElement("table");
  summaryTable.className = "infra-table";
  const summaryHead = document.createElement("thead");
  summaryHead.innerHTML = `
    <tr>
      <th>Need</th>
      <th class="text-right">Required</th>
      <th class="text-right">Provided</th>
      <th class="text-right">Fulfillment</th>
      <th class="text-right">Status</th>
    </tr>
  `;
  summaryTable.appendChild(summaryHead);

  const summaryBody = document.createElement("tbody");
  for (const need of NEED_ORDER) {
    const req = requiredNeeds[need] || 0;
    const prov = provided[need] || 0;
    const fulfillment = req > 0 ? prov / req : 1;
    const met = fulfillment >= 0.7;

    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${capitalize(need)}</td>
      <td class="text-right">${req.toLocaleString(undefined, { maximumFractionDigits: 1 })}</td>
      <td class="text-right">${prov.toLocaleString(undefined, { maximumFractionDigits: 1 })}</td>
      <td class="text-right">${(fulfillment * 100).toFixed(1)}%</td>
      <td class="text-right" style="color:${met ? "#4ade80" : "#f87171"}">${met ? "✓" : "✗"}</td>
    `;
    summaryBody.appendChild(tr);
  }
  summaryTable.appendChild(summaryBody);
  tableContainer.appendChild(summaryTable);
}



loadInfraBtn.addEventListener("click", loadInfrastructure);

document.addEventListener("DOMContentLoaded", async () => {
  // URL param takes priority; fall back to last-used planet from localStorage
  const urlPlanet = new URL(window.location.href).searchParams.get("planet");
  const savedPlanet = urlPlanet || localStorage.getItem(PLANET_STORAGE_KEY);

  if (savedPlanet) {
    planetInput.value = savedPlanet;
    if (urlPlanet) {
      // Auto-load when planet is specified in the URL
      await loadInfrastructure();
    }
  }
});



</script>