<style>
  #governor-helper-root {
    margin: 0 auto;
    text-align: left;
    padding: 1rem;
  }

  #governor-helper-root button {
    margin: 2px;
    padding: 3px 10px 3px 10px;
  }

  /* Section wrappers */
  .section-retrieved, .section-calculated {
    margin-top: 1.5rem;
    padding: 0.75rem 1rem 1rem;
    border-radius: 6px;
  }
  .section-retrieved {
    border-left: 3px solid rgb(99 102 241);
    background: rgba(99, 102, 241, 0.06);
  }
  .section-calculated {
    border-left: 3px solid rgb(16 185 129);
    background: rgba(16, 185, 129, 0.06);
  }
  .section-label {
    font-size: 0.7rem;
    font-weight: 700;
    letter-spacing: 0.1em;
    text-transform: uppercase;
    color: var(--text-secondary);
    margin-bottom: 0.75rem;
  }

  /* Side-by-side layout for infra + current needs */
  .two-col-infra {
    display: grid;
    grid-template-columns: auto 1fr;
    gap: 2rem;
    align-items: start;
  }

  /* Planet header */
  .planet-name {
    font-size: 1.25rem;
    font-weight: 700;
    margin-bottom: 0.2rem;
  }
  .planet-id {
    font-size: 1rem;
    font-weight: 400;
    color: var(--text-secondary);
    margin-left: 0.4rem;
  }
  .planet-meta {
    font-size: 0.85rem;
    color: var(--text-secondary);
    margin-bottom: 0.75rem;
  }
</style>

<div id="governor-helper-root" class="calculator">

  <div style="display:flex;gap:0.5rem;align-items:center;flex-wrap:wrap;margin-bottom:0.5rem">
    <input id="planetInput" type="text" placeholder="RC-040b or Malahat" />
    <button id="loadInfraBtn">Load Infrastructure</button>
  </div>
  <div id="warnings"></div>

  <div id="section-retrieved" class="section-retrieved" style="display:none">
    <div class="section-label">Live Data</div>
    <div id="planet-header"></div>
    <div class="two-col-infra">
      <div>
        <h3 class="mb-2 font-bold">Infrastructure Buildings</h3>
        <div id="infra-table-container"></div>
      </div>
      <div>
        <h3 class="mt-4 mb-2 font-bold">Last Population Report</h3>
        <div id="workforce-table-container"></div>
        <h3 class="mb-2 font-bold">Last Report's Need Fulfillment</h3>
        <div id="needs-table-container"></div>
      </div>
    </div>
  </div>

  <div id="section-calculated" class="section-calculated" style="display:none">
    <div class="section-label">Calculated</div>
    <div style="display:flex;gap:1.5rem;align-items:center;flex-wrap:wrap;margin-bottom:1rem">
      <label style="display:flex;align-items:center;gap:0.35rem;color:var(--text-secondary);font-size:0.9rem">
        Target fulfillment
        <input id="targetFulfillment" type="number" min="1" max="100" value="70" style="width:4rem" />
        %
      </label>
      <label style="display:flex;align-items:center;gap:0.35rem;color:var(--text-secondary);font-size:0.9rem">
        Supply days
        <input id="supplyDays" type="number" min="1" value="30" style="width:4rem" />
      </label>
    </div>
    <h3 class="mt-2 mb-2 font-bold">Projected Need Fulfillment</h3>
    <div id="projected-needs-container"></div>
    <h3 class="mt-6 mb-2 font-bold">Recommended Supply Plan</h3>
    <div id="supply-plan-container"></div>
  </div>

</div>

<script type="module">


  import { fetchPricing, priceData } from "/pricing-and-materials.js";
  import { UPKEEP_BUILDINGS, UPKEEP_NEED_TYPES, WEIGHTS } from "/infra-data.js";

const PLANET_STORAGE_KEY = "gov_helper_selected_planet";
const REFRESH_DURATION = 1 * 3600 * 1000;
const PLANET_CACHE_DURATION = 24 * 3600 * 1000;

const planetInput            = document.getElementById("planetInput");
const loadInfraBtn           = document.getElementById("loadInfraBtn");
const targetFulfillmentInput = document.getElementById("targetFulfillment");
const warnings               = document.getElementById("warnings");

// Preserved across loads so the fulfillment input can trigger recalculation
let lastRequiredNeeds  = null;
let lastLatestProjects = null;
const sectionRetrieved    = document.getElementById("section-retrieved");
const sectionCalculated   = document.getElementById("section-calculated");
const planetHeaderEl      = document.getElementById("planet-header");
const infraTableCont      = document.getElementById("infra-table-container");
const needsTableCont      = document.getElementById("needs-table-container");
const workforceTableCont  = document.getElementById("workforce-table-container");
const supplyPlanCont      = document.getElementById("supply-plan-container");
const projectedNeedsCont  = document.getElementById("projected-needs-container");

async function fetchPlanet(planetId) {
  const cacheKey = `planet_${planetId}`;
  const cached = localStorage.getItem(cacheKey);
  if (cached) {
    try {
      const { timestamp, data } = JSON.parse(cached);
      if (Date.now() - timestamp < PLANET_CACHE_DURATION) return data;
    } catch {}
  }
  const response = await fetch(`https://rest.fnar.net/planet/${planetId}`);
  if (!response.ok) throw new Error("Planet not found");
  const data = await response.json();
  localStorage.setItem(cacheKey, JSON.stringify({ timestamp: Date.now(), data }));
  return data;
}

async function fetchInfrastructure(planetId) {
  const cacheKey = `infra_${planetId}`;
  const cached = localStorage.getItem(cacheKey);

  if (cached) {
    try {
      const { timestamp, data } = JSON.parse(cached);
      if (Date.now() - timestamp < REFRESH_DURATION) {
        console.log("Loaded infrastructure from cache:", planetId);
        return data;
      }
    } catch {}
  }

  const url = `https://rest.fnar.net/infrastructure/${planetId}`;
  const response = await fetch(url);

  if (!response.ok) {
    throw new Error("Planet not found");
  }

  const data = await response.json();

  localStorage.setItem(
    cacheKey,
    JSON.stringify({
      timestamp: Date.now(),
      data,
    })
  );

  return data;
}

/**
 * Extract the entries from the largest SimulationPeriod.
 * Returns { projectMap, maxPeriod, startEpochMs }.
 */
function extractLatestProjects(data) {
  const projects = data.InfrastructureProjects || [];
  if (!projects.length) return { projectMap: new Map(), maxPeriod: null, startEpochMs: null };

  let maxPeriod = -Infinity;
  for (const p of projects) {
    if (p.SimulationPeriod > maxPeriod) maxPeriod = p.SimulationPeriod;
  }

  const latest = projects.filter(p => p.SimulationPeriod === maxPeriod);
  const byTicker = new Map();
  for (const project of latest) {
    byTicker.set(project.Ticker, {
      level: project.Level,
      currentLevel: project.CurrentLevel,
    });
  }

  return { projectMap: byTicker, maxPeriod };
}

function formatRelativeTime(epochMs) {
  if (!epochMs) return "";
  const now = Date.now();
  let diff = epochMs - now;
  const future = diff > 0;
  diff = Math.abs(diff);
  const sec = Math.floor(diff / 1000);
  const min = Math.floor(sec / 60);
  const hr  = Math.floor(min / 60);
  const day = Math.floor(hr / 24);
  let primary = "", secondary = "";
  if (day > 0)      { primary = `${day}d`;  secondary = `${hr % 24}h`; }
  else if (hr > 0)  { primary = `${hr}h`;   secondary = `${min % 60}m`; }
  else if (min > 0) { primary = `${min}m`;  secondary = `${sec % 60}s`; }
  else              { primary = `${sec}s`; }
  const timeStr = secondary && !secondary.startsWith("0") ? `${primary} ${secondary}` : primary;
  return future ? `in ${timeStr}` : `${timeStr} ago`;
}

function getTarget() {
  const val = parseFloat(targetFulfillmentInput.value);
  return (!isNaN(val) && val >= 1 && val <= 100) ? val / 100 : 0.7;
}

function renderPlanetHeader(planetData, maxPeriod, startEpochMs) {
  const name = planetData.PlanetName || "";
  const id   = planetData.PlanetNaturalId || "";
  const startDate = startEpochMs
    ? new Date(startEpochMs).toLocaleString(undefined, {
        year: "numeric", month: "short", day: "numeric",
        hour: "2-digit", minute: "2-digit",
      })
    : "—";
  const endEpochMs = startEpochMs ? startEpochMs + 7 * 24 * 3600 * 1000 : null;
  const endsIn = endEpochMs ? formatRelativeTime(endEpochMs) : "—";
  planetHeaderEl.innerHTML = `
    <div class="planet-name">${name}<span class="planet-id">${id}</span></div>
    <div class="planet-meta">Simulation Period ${maxPeriod ?? "—"} · Started ${startDate} · Ends ${endsIn}</div>
  `;
}

function extractLatestReport(data) {
  const reports = data.InfrastructureReports || [];
  if (!reports.length) return null;

  let latest = reports[0];

  for (const report of reports) {
    if (report.SimulationPeriod > latest.SimulationPeriod) {
      latest = report;
    }
  }

  return latest;
}


/**
 * Render infrastructure table
 */
function renderInfrastructureTable(projectMap) {
  if (!projectMap.size) return null;

  const table = document.createElement("table");
  table.className = "table-auto border-collapse text-sm";

  table.innerHTML = `
    <thead>
      <tr>
        <th class="text-left pr-4">Building</th>
        <th class="text-right pr-4">Built</th>
        <th class="text-right">Current</th>
      </tr>
    </thead>
  `;

  const tbody = document.createElement("tbody");

  const upkeepOrder = UPKEEP_BUILDINGS.map(b => b.ticker);
  const sortedTickers = [...projectMap.keys()].sort(
    (a, b) => {
      const ai = upkeepOrder.indexOf(a);
      const bi = upkeepOrder.indexOf(b);
      // Known buildings first (in UPKEEP_BUILDINGS order), unknown alphabetically after
      if (ai === -1 && bi === -1) return a.localeCompare(b);
      if (ai === -1) return 1;
      if (bi === -1) return -1;
      return ai - bi;
    }
  );

  for (const ticker of sortedTickers) {
    const { level, currentLevel } = projectMap.get(ticker);

    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td class="pr-4">${ticker}</td>
      <td class="text-right pr-4">${level}</td>
      <td class="text-right">${currentLevel}</td>
    `;

    tbody.appendChild(tr);
  }

  table.appendChild(tbody);
  return table;
}

function renderWorkforceTable(report) {
  const tiers = [
    "Pioneer",
    "Settler",
    "Technician",
    "Engineer",
    "Scientist"
  ];

  const table = document.createElement("table");
  table.className = "table-auto border-collapse text-sm mb-6";

  table.innerHTML = `
    <thead>
      <tr>
        <th class="text-left pr-4">Metric</th>
        ${tiers.map(t => `<th class="text-right pr-4">${t}</th>`).join("")}
      </tr>
    </thead>
  `;

  const tbody = document.createElement("tbody");

  const rows = [
    {
      label: "Population",
      key: "NextPopulation"
    },
    {
      label: "Change",
      key: "PopulationDifference"
    },
    {
      label: "Happiness",
      key: "AverageHappiness",
      format: v => (v * 100).toFixed(1) + "%"
    },
    {
      label: "Unemployment",
      key: "UnemploymentRate",
      format: v => (v * 100).toFixed(1) + "%"
    },
    {
      label: "Open Jobs",
      key: "OpenJobs"
    }
  ];

  for (const row of rows) {
    const tr = document.createElement("tr");

    const cells = tiers.map(tier => {
      const field = row.key + tier;
      const value = report[field];

      if (row.format) {
        return `<td class="text-right pr-4">${row.format(value)}</td>`;
      }

      return `<td class="text-right pr-4">${value.toLocaleString()}</td>`;
    });

    tr.innerHTML = `
      <td class="pr-4 font-semibold">${row.label}</td>
      ${cells.join("")}
    `;

    tbody.appendChild(tr);
  }

  table.appendChild(tbody);
  return table;
}

function renderNeedsTable(report) {
  const needs = [
    { key: "LifeSupport", label: "Life Support" },
    { key: "Safety",      label: "Safety" },
    { key: "Health",      label: "Health" },
    { key: "Comfort",     label: "Comfort" },
    { key: "Culture",     label: "Culture" },
    { key: "Education",   label: "Education" },
  ];

  const table = document.createElement("table");
  table.className = "table-auto border-collapse text-sm";

  const tbody = document.createElement("tbody");
  for (const { key, label } of needs) {
    const value = report["NeedFulfillment" + key] ?? 0;
    const pct = (value * 100).toFixed(1) + "%";
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td class="pr-4 font-semibold">${label}</td>
      <td class="text-right pr-3">${pct}</td>
    `;
    tbody.appendChild(tr);
  }
  table.appendChild(tbody);
  return table;
}


async function loadInfrastructure() {
  const planetId = planetInput.value.trim();
  if (!planetId) {
    alert("Please enter a planet identifier.");
    return;
  }

  localStorage.setItem(PLANET_STORAGE_KEY, planetId);
  const url = new URL(window.location.href);
  url.searchParams.set("planet", planetId);
  history.replaceState(null, "", url.toString());

  sectionRetrieved.style.display = "none";
  sectionCalculated.style.display = "none";
  warnings.textContent = "Loading…";

  try {
    // Fetch pricing, planet metadata, and infrastructure data in parallel
    const [infraData, planetData] = await Promise.all([
      fetchInfrastructure(planetId),
      fetchPlanet(planetId),
      fetchPricing(),
    ]);

    const { projectMap: latestProjects, maxPeriod } = extractLatestProjects(infraData);
    const latestReport = extractLatestReport(infraData);
    const startEpochMs = latestReport.TimestampMs;

    warnings.textContent = "";

    // ── Live Data ────────────────────────────────────────────────
    renderPlanetHeader(planetData, maxPeriod, startEpochMs);

    infraTableCont.innerHTML = "";
    const infraTable = renderInfrastructureTable(latestProjects);
    infraTableCont.appendChild(infraTable ?? Object.assign(document.createElement("p"), { textContent: "No infrastructure found." }));

    needsTableCont.innerHTML = "";
    workforceTableCont.innerHTML = "";
    if (latestReport) {
      needsTableCont.appendChild(renderNeedsTable(latestReport));
      workforceTableCont.appendChild(renderWorkforceTable(latestReport));
    }

    sectionRetrieved.style.display = "";

    // Calculated Data
    if (latestReport) {
      const population = {
        pioneer:    latestReport.NextPopulationPioneer,
        settler:    latestReport.NextPopulationSettler,
        technician: latestReport.NextPopulationTechnician,
        engineer:   latestReport.NextPopulationEngineer,
        scientist:  latestReport.NextPopulationScientist,
      };
      const requiredNeeds = calculateRequiredNeeds(population);
      lastRequiredNeeds  = requiredNeeds;
      lastLatestProjects = latestProjects;
      renderCheapestFulfillmentTable(requiredNeeds, latestProjects);
      sectionCalculated.style.display = "";
    }

  } catch (err) {
    console.error(err);
    warnings.textContent = "Failed to load: " + err.message;
  }
}

function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

function efficiencyColor(value) {
  value = Math.pow(value, 0.5);
  const r = value < 0.5 ? (value * 2) * 255 : 255;
  const g = value < 0.5 ? 255 : (1 - (value - 0.5) * 2) * 255;
  return `rgb(${r}, ${g}, 0, 0.3)`;
}

function calculateRequiredNeeds(pop) {
  const needs = {
    safety: 0,
    health: 0,
    comfort: 0,
    culture: 0,
    education: 0
  };

  Object.entries(pop).forEach(([tier, count]) => {
    const weights = WEIGHTS[tier];
    if (!weights) return;

    Object.entries(weights).forEach(([need, weight]) => {
      needs[need] += count * weight;
    });
  });

  return needs;
}

function computeCheapestFulfillment(requiredNeeds, latestProjects) {
  const TARGET = getTarget();

  // Each option = one (building, material) pair.
  // Quantities are stored PER LEVEL so phase 2 can freely adjust active levels.
  const allOptions = [];
  for (const building of UPKEEP_BUILDINGS) {
    const project = latestProjects.get(building.ticker);
    if (!project || !project.level) continue;
    const builtLevel = project.level;
    const n = building.materials.length;

    for (const mat of building.materials) {
      const price = priceData[mat.ticker];
      if (!price) continue;

      const contribPerLevel = {};
      for (const [need, needAmt] of Object.entries(building.needs)) {
        if (needAmt > 0) contribPerLevel[need] = needAmt / n;
      }
      if (Object.keys(contribPerLevel).length === 0) continue;

      allOptions.push({
        building: building.ticker,
        builtLevel,
        activeLevel: builtLevel, // reduced in phase 2
        ticker: mat.ticker,
        qtyPerDayPerLevel: mat.qtyPerDay,
        costPerLevel: mat.qtyPerDay * price,
        contribPerLevel,
      });
    }
  }

  // ── Phase 1: greedy material selection ──────────────────────────────────
  // Cost-effectiveness = contribPerLevel / costPerLevel (level cancels out),
  // so material ranking is independent of how many levels are active.
  const selected = new Set();
  const remaining = {};
  for (const [need, req] of Object.entries(requiredNeeds)) {
    remaining[need] = req * TARGET;
  }

  for (const need of Object.keys(requiredNeeds)) {
    // Credit already-selected materials at their full built level
    for (const idx of selected) {
      remaining[need] -= (allOptions[idx].contribPerLevel[need] ?? 0) * allOptions[idx].builtLevel;
    }
    if (remaining[need] <= 0) continue;

    const candidates = allOptions
      .map((opt, i) => ({ opt, i }))
      .filter(({ i }) => !selected.has(i))
      .filter(({ opt }) => (opt.contribPerLevel[need] ?? 0) > 0)
      .sort(({ opt: a }, { opt: b }) =>
        b.contribPerLevel[need] / b.costPerLevel - a.contribPerLevel[need] / a.costPerLevel
      );

    for (const { opt, i } of candidates) {
      if (remaining[need] <= 0) break;
      selected.add(i);
      // Apply all contributions so cross-need buildings aren't double-purchased
      for (const [n2, c] of Object.entries(opt.contribPerLevel)) {
        remaining[n2] = (remaining[n2] ?? 0) - c * opt.builtLevel;
      }
    }
  }

  if (selected.size === 0) return [];

  // ── Phase 2: minimize active levels to avoid overshooting ───────────────
  // Compute surplus over target at full built levels.
  const provided = {};
  for (const idx of selected) {
    for (const [need, c] of Object.entries(allOptions[idx].contribPerLevel)) {
      provided[need] = (provided[need] ?? 0) + c * allOptions[idx].builtLevel;
    }
  }
  const surplus = {};
  for (const [need, req] of Object.entries(requiredNeeds)) {
    surplus[need] = (provided[need] ?? 0) - req * TARGET;
  }

  // Aggregate per-building totals for the reduction pass
  const bldMap = new Map();
  for (const idx of selected) {
    const opt = allOptions[idx];
    if (!bldMap.has(opt.building)) {
      bldMap.set(opt.building, { indices: [], builtLevel: opt.builtLevel, costPerLvl: 0, contribPerLvl: {} });
    }
    const e = bldMap.get(opt.building);
    e.indices.push(idx);
    e.costPerLvl += opt.costPerLevel;
    for (const [need, c] of Object.entries(opt.contribPerLevel)) {
      e.contribPerLvl[need] = (e.contribPerLvl[need] ?? 0) + c;
    }
  }

  // Reduce most-expensive buildings first to maximise savings
  const sortedBlds = [...bldMap.values()].sort((a, b) => b.costPerLvl - a.costPerLvl);

  for (const bData of sortedBlds) {
    let maxReduce = bData.builtLevel;
    for (const [need, c] of Object.entries(bData.contribPerLvl)) {
      if (c <= 0) continue;
      maxReduce = Math.min(maxReduce, Math.floor(surplus[need] / c));
    }
    maxReduce = Math.max(0, maxReduce);

    // Update surplus to reflect the reduction before processing next building
    for (const [need, c] of Object.entries(bData.contribPerLvl)) {
      surplus[need] -= maxReduce * c;
    }
    const newActive = bData.builtLevel - maxReduce;
    for (const idx of bData.indices) allOptions[idx].activeLevel = newActive;
  }

  // ── Return final plan ────────────────────────────────────────────────────
  return [...selected]
    .filter(i => allOptions[i].activeLevel > 0) // drop fully deactivated buildings
    .map(i => {
      const opt = allOptions[i];
      const a = opt.activeLevel;
      return {
        building: opt.building,
        builtLevel: opt.builtLevel,
        activeLevel: a,
        ticker: opt.ticker,
        qtyPerDay: opt.qtyPerDayPerLevel * a,
        cost: opt.costPerLevel * a,
        contributions: Object.fromEntries(
          Object.entries(opt.contribPerLevel).map(([k, v]) => [k, v * a])
        ),
      };
    });
}

function renderCheapestFulfillmentTable(requiredNeeds, latestProjects) {
  supplyPlanCont.innerHTML = "";
  projectedNeedsCont.innerHTML = "";

  const selected = computeCheapestFulfillment(requiredNeeds, latestProjects);

  if (selected.length === 0) {
    // Diagnose exactly why nothing was selected
    const presentBuildings = UPKEEP_BUILDINGS.filter(b => {
      const p = latestProjects.get(b.ticker);
      return p && p.level > 0;
    });

    const reasons = [];

    if (presentBuildings.length === 0) {
      reasons.push("No infrastructure buildings are present on this planet yet.");
    } else {
      const missingPrices = new Set();
      for (const b of presentBuildings) {
        for (const mat of b.materials) {
          if (!priceData[mat.ticker]) missingPrices.add(mat.ticker);
        }
      }
      if (missingPrices.size > 0) {
        reasons.push(`Market prices are missing for: ${[...missingPrices].sort().join(", ")}. Prices may still be loading — try again in a moment.`);
      }
      if (missingPrices.size === 0) {
        reasons.push("All buildings have prices but no material contributes to the outstanding needs. This is unexpected — please report it.");
      }
    }

    const msg = document.createElement("p");
    msg.style.color = "#f87171";
    msg.textContent = "No supply plan could be calculated. " + reasons.join(" ");
    supplyPlanCont.appendChild(msg);
    return;
  }

  // Compute totals for the summary
  const provided = {};
  let totalCost = 0;
  for (const opt of selected) {
    totalCost += opt.cost;
    for (const [need, contrib] of Object.entries(opt.contributions)) {
      provided[need] = (provided[need] || 0) + contrib;
    }
  }

  // --- Supply plan table grouped by building ---
  const byBuilding = new Map();
  for (const opt of selected) {
    if (!byBuilding.has(opt.building)) byBuilding.set(opt.building, []);
    byBuilding.get(opt.building).push(opt);
  }

  const planTable = document.createElement("table");
  planTable.className = "infra-table";
  const planHead = document.createElement("thead");
  planHead.innerHTML = `
    <tr>
      <th>Building</th>
      <th>Material</th>
      <th class="text-right">Qty / Day</th>
      <th class="text-right">Daily Cost</th>
      <th>Needs Supplied</th>
      <th class="text-right">Need Qty</th>
      <th class="text-right">$ / Need</th>
    </tr>
  `;
  planTable.appendChild(planHead);

  // Pre-compute $/need for each option so we can normalise for coloring
  const allSelected = [...byBuilding.values()].flat();
  const dollarPerNeed = opt => {
    const totalNeed = Object.values(opt.contributions).reduce((s, v) => s + v, 0);
    return totalNeed > 0 ? opt.cost / totalNeed : Infinity;
  };
  const dpnValues = allSelected.map(dollarPerNeed).filter(v => isFinite(v));
  const dpnMin = Math.min(...dpnValues);
  const dpnMax = Math.max(...dpnValues);
  const dpnRange = dpnMax - dpnMin || 1;

  const planBody = document.createElement("tbody");
  for (const [building, opts] of byBuilding) {
    for (const opt of opts) {
      const needNames = Object.keys(opt.contributions).map(capitalize).join(", ");
      const needQtys = Object.values(opt.contributions)
        .map(v => v.toLocaleString(undefined, { maximumFractionDigits: 1 }))
        .join(", ");
      const dpn = dollarPerNeed(opt);
      const norm = isFinite(dpn) ? (dpn - dpnMin) / dpnRange : 1; // 0 = best, 1 = worst
      const rowColor = efficiencyColor(norm);
      const tr = document.createElement("tr");
      tr.style.backgroundColor = rowColor;
      tr.innerHTML = `
        <td>${opt.activeLevel < opt.builtLevel
          ? `<span style="color:#4ade80;font-weight:600">${opt.activeLevel}</span><span style="color:var(--text-secondary)">/${opt.builtLevel}</span> ${building}`
          : `${opt.activeLevel} ${building}`
        }</td>
        <td>${opt.ticker}</td>
        <td class="text-right">${opt.qtyPerDay.toLocaleString(undefined, { maximumFractionDigits: 2 })}</td>
        <td class="text-right">${opt.cost.toLocaleString(undefined, { maximumFractionDigits: 2 })}</td>
        <td>${needNames}</td>
        <td class="text-right">${needQtys}</td>
        <td class="text-right">${isFinite(dpn) ? dpn.toFixed(4) : "—"}</td>
      `;
      planBody.appendChild(tr);
    }
  }
  const totalRow = document.createElement("tr");
  totalRow.innerHTML = `
    <td colspan="6" class="font-semibold text-right">Total daily cost</td>
    <td class="text-right font-semibold">${totalCost.toLocaleString(undefined, { maximumFractionDigits: 2 })}</td>
  `;
  planBody.appendChild(totalRow);
  planTable.appendChild(planBody);
  supplyPlanCont.appendChild(planTable);

  // --- Need fulfillment summary ---
  const NEED_ORDER = ["safety", "health", "comfort", "culture", "education"];

  const summaryTable = document.createElement("table");
  summaryTable.className = "infra-table";
  const summaryHead = document.createElement("thead");
  summaryHead.innerHTML = `
    <tr>
      <th>Need</th>
      <th class="text-right">Required</th>
      <th class="text-right">Provided</th>
      <th class="text-right">Fulfillment</th>
      <th class="text-right">Status</th>
    </tr>
  `;
  summaryTable.appendChild(summaryHead);

  const summaryBody = document.createElement("tbody");
  for (const need of NEED_ORDER) {
    const req = requiredNeeds[need] || 0;
    const prov = provided[need] || 0;
    const fulfillment = req > 0 ? prov / req : 1;
    const met = fulfillment >= getTarget();

    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${capitalize(need)}</td>
      <td class="text-right">${req.toLocaleString(undefined, { maximumFractionDigits: 1 })}</td>
      <td class="text-right">${prov.toLocaleString(undefined, { maximumFractionDigits: 1 })}</td>
      <td class="text-right">${(fulfillment * 100).toFixed(1)}%</td>
      <td class="text-right" style="color:${met ? "#4ade80" : "#f87171"}">${met ? "✓" : "✗"}</td>
    `;
    summaryBody.appendChild(tr);
  }
  summaryTable.appendChild(summaryBody);
  projectedNeedsCont.appendChild(summaryTable);
}



loadInfraBtn.addEventListener("click", loadInfrastructure);

targetFulfillmentInput.addEventListener("input", () => {
  if (lastRequiredNeeds && lastLatestProjects && sectionCalculated.style.display !== "none") {
    renderCheapestFulfillmentTable(lastRequiredNeeds, lastLatestProjects);
  }
});

document.addEventListener("DOMContentLoaded", async () => {
  // URL param takes priority; fall back to last-used planet from localStorage
  const urlPlanet = new URL(window.location.href).searchParams.get("planet");
  const savedPlanet = urlPlanet || localStorage.getItem(PLANET_STORAGE_KEY);

  if (savedPlanet) {
    planetInput.value = savedPlanet;
    if (urlPlanet) {
      // Auto-load when planet is specified in the URL
      await loadInfrastructure();
    }
  }
});



</script>